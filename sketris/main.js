/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/sketris.js":
/*!************************!*\
  !*** ./src/sketris.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n// import * as LZString from \"lz-string\";\r\n// import { start } from \"repl\";\r\n// import { needValidate } from \"schema-utils\";\r\n\r\n\r\nclass GameBoard {\r\n\r\n    constructor(rows=20, cols=10, tileSize=30, spawnArea=2) {\r\n\r\n        this.rows = rows;\r\n        this.cols = cols;\r\n        this.tileSize = tileSize;\r\n        this.spawnArea = spawnArea;\r\n\r\n        this.boardHeight = (rows+this.spawnArea)*tileSize;   \r\n        this.boardWidth = cols*tileSize;   \r\n\r\n        this.playfield = new Playfield(this.rows, this.cols, this.tileSize, this.spawnArea);\r\n        this.hold = new Hold(this.tileSize);\r\n        this.queue = new Queue(this.tileSize);\r\n\r\n        this.sketcher = new Sketcher(this.playfield, () => this.getActivePiece(), () => this.saveState());\r\n        this.history = new BoardHistory();\r\n\r\n        this.activePiece =  null;\r\n        this.isPaused = false;\r\n    }\r\n\r\n    loadData(dataString){\r\n\r\n        try {\r\n            let b = _utils_js__WEBPACK_IMPORTED_MODULE_0__.stringToData(dataString);\r\n            this.playfield.loadData(b);\r\n        }\r\n        catch {\r\n            console.log(\"invalid data\");\r\n        }\r\n    }\r\n    \r\n    update(){\r\n        this.queue.updateQueue();\r\n        if(!this.activePiece || this.activePiece.name !== this.queue.getCurrent()){\r\n            // this.activePiece = new Piece(this.queue.getCurrent());\r\n            // should queue changes be reflected in history?\r\n            this.spawnPiece();\r\n        }\r\n\r\n    }\r\n\r\n    lstGuide() {\r\n        // mirror 0,1 3,4 to tallest\r\n\r\n        let getCol = (i) => {return this.playfield.board.map((r) => r[i])}\r\n        let topActiveIndex = (c) => {\r\n            for(let i=0; i<c.length; i++){\r\n                if(c[i].active){\r\n                    return c[i].y\r\n                }\r\n            }\r\n            return this.rows + this.spawnArea;\r\n        }\r\n        let topSelectIndex = (c) => {\r\n            for(let i=0; i<c.length; i++){\r\n                if(c[i].selected){\r\n                    return c[i].y\r\n                }\r\n            }\r\n            return this.rows + this.spawnArea;\r\n        }\r\n        \r\n        let cols = [];\r\n        for(let i=0; i<this.cols; i++){\r\n            cols.push(getCol(i));\r\n        }\r\n\r\n\r\n        let mirror = (a,b) =>{\r\n            let topA = topActiveIndex(cols[a]);\r\n            let topB = topActiveIndex(cols[b]);\r\n\r\n            let lowCol = topA >= topB ? cols[a] : cols[b];\r\n            let highCol = topA >= topB ? cols[b] : cols[a];\r\n            let topInd = topActiveIndex(highCol);\r\n\r\n            if(topA == topB){\r\n                for(let i=(this.rows + this.spawnArea)-1; i >= 0; i--){\r\n                    lowCol[i].selected = false;\r\n                    highCol[i].selected = false;\r\n\r\n                };\r\n                return;\r\n            }\r\n\r\n            for(let i=(this.rows + this.spawnArea)-1; i >= 0; i--){\r\n                let t = lowCol[i];\r\n                if((i >= topInd && !t.active && highCol[i].active) || highCol[i].selected){\r\n                    t.selected = true;\r\n                }else t.selected = false;\r\n\r\n                if(i >= topInd){\r\n                    highCol[i].selected = false;\r\n                }\r\n\r\n                if(i < topInd && (lowCol[i].selected || highCol[i].selected)){\r\n                    lowCol[i].selected = true;\r\n                    highCol[i].selected = true;\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n        \r\n        mirror(0,4);\r\n        mirror(1,3);\r\n\r\n        //lst logic\r\n\r\n        // return\r\n\r\n        // check tops, 2 cases\r\n\r\n        // select appropriate\r\n\r\n    }\r\n\r\n    countToFourGuide() {\r\n        let getCol = (i) => {return this.playfield.board.map((r) => r[i])}\r\n        let topActiveIndex = (c) => {\r\n            for(let i=0; i<c.length; i++){\r\n                if(c[i].active){\r\n                    return c[i].y\r\n                }\r\n            }\r\n            return this.rows + this.spawnArea;\r\n        }\r\n\r\n        // find first garbage row covering well\r\n        let lowColTop = 0;\r\n        for (let i = 0; i < this.playfield.cols; i++) {\r\n            lowColTop = Math.max(topActiveIndex(getCol(i)), lowColTop);\r\n        }\r\n\r\n        // console.log(lowColTop);\r\n\r\n        // draw 4x10 box starting at row\r\n        this.playfield.ctx.fillStyle = \"rgba(200,200,200, 0.08)\";\r\n        this.playfield.ctx.fillRect(0, this.tileSize*(lowColTop-4), this.playfield.canvas.width, this.tileSize*4);\r\n\r\n        this.playfield.ctx.strokeStyle = \"rgba(200,0,200, 0.5)\";\r\n        this.playfield.ctx.moveTo(0, this.tileSize*lowColTop)\r\n        this.playfield.ctx.lineTo(this.playfield.canvas.width, this.tileSize*lowColTop);\r\n        this.playfield.ctx.stroke();\r\n        // this.playfield.ctx.fillRect(50,50,50,50);\r\n        // this.playfield.ctx.stroke();\r\n\r\n        // highlight avoid box\r\n\r\n    }\r\n\r\n    getActivePiece() {\r\n        return this.activePiece;\r\n    }\r\n\r\n    renderBoard(){\r\n        this.playfield.render(this.isPaused);\r\n        this.queue.renderQueue();\r\n        this.hold.renderHold();\r\n        this.renderActive();\r\n\r\n        // temp testing\r\n        // this.countToFourGuide();\r\n    }\r\n\r\n    renderActive(){\r\n        if(this.activePiece){\r\n            // TODO colored ghost\r\n            // draw ghost first\r\n            let ghost = this.activePiece.copy();\r\n            let origColor = _utils_js__WEBPACK_IMPORTED_MODULE_0__.parseColor(ghost.color)\r\n            ghost.color = \"rgba(\" + origColor.r + \",\" + origColor.g + \",\" + origColor.b + \",\" + 0.5 + \")\"; \r\n\r\n            this.shiftInstant(\"down\",false, ghost);\r\n            \r\n            for (let i = 0; i < ghost.tiles.length; i++) {\r\n                this.playfield.colorTile(ghost.tiles[i]);\r\n            }\r\n\r\n            // activePiece\r\n            for (let i = 0; i < this.activePiece.tiles.length; i++) {\r\n                this.playfield.colorTile(this.activePiece.tiles[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    // loadPlayfield(p) {\r\n    //     this.playfield = p;\r\n    //     this.sketcher = new Sketcher(thiskplayfield);\r\n    // }\r\n\r\n    saveState(){\r\n        this.history.addState(this.playfield.copy(), this.queue.copy(), this.hold.copy());\r\n        // let s = GameState.gameStateToString(this.playfield);\r\n\r\n        // s = \"ARGZAY0BARCZAQCNAQEpjQEBEoiNAQESiQIBEJEBAJiIARGRAZkBAROEmAERhQKA\";\r\n        console.log(_utils_js__WEBPACK_IMPORTED_MODULE_0__.dataToString(this.playfield.getData()));\r\n        // this.playfield.loadData(d);\r\n\r\n        // let byteBoard = new Uint8Array(d);\r\n\r\n\r\n        // this.playfield = GameState.stringToGameState(s);\r\n\r\n\r\n        // console.log(this.history.getState());\r\n        // BoardHistory.stateToString(this.history.getState());\r\n        // let a=JSON.stringify(this.history)\r\n        // let b=LZString.compress(a);\r\n\r\n        // console.log(' ');\r\n        // console.log(a);\r\n        // console.log(new Blob([a]).size);\r\n        // console.log(' ');\r\n        // console.log(b);\r\n        // console.log(new Blob([b]).size);\r\n        // console.log(' ');\r\n\r\n    }\r\n\r\n    setState(n){\r\n        let state = this.history.getState(n);\r\n        if(state){\r\n            this.playfield.setField(state);\r\n            this.queue = state.queue.copy();\r\n            this.hold = state.hold.copy();\r\n            this.spawnPiece(false);\r\n            // this.activePiece = new Piece(this.queue.getCurrent());\r\n            this.renderBoard();\r\n        }\r\n    }\r\n\r\n    spawnPiece(newState=true, das=null) {\r\n        let spawnX = Math.ceil(this.cols / 2) - 2;\r\n        this.activePiece = new Piece(this.queue.getCurrent(), spawnX, 0);\r\n        if(this.collisionCheck(this.activePiece, this.playfield)){\r\n            this.activePiece = null;\r\n            return false;\r\n        };\r\n\r\n        if(newState){\r\n            this.saveState();\r\n            // this.history.addState(this.playfield.copy(), this.queue.copy(), this.hold.copy());\r\n        }\r\n\r\n        if(das === 'r') this.shiftInstant('right');\r\n        else if(das === 'l') this.shiftInstant('left');\r\n\r\n        return true;\r\n    }\r\n\r\n    holdPiece(){\r\n        if(this.activePiece){\r\n            if(this.hold.pieceName){\r\n                let holdName = this.hold.getHold();\r\n                this.hold.setHold(this.activePiece.name); \r\n                this.queue.setCurrent(holdName);\r\n            }\r\n            else{\r\n                this.hold.setHold(this.activePiece.name);\r\n                this.queue.queueStep();\r\n                this.spawnPiece();\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    collisionCheck(piece, playfield) {\r\n        for (let i = 0; i < piece.tiles.length; i++) {\r\n            let tile = piece.tiles[i];\r\n            if(tile.y < 0 || tile.x < 0  \r\n                || tile.y > (this.rows+this.spawnArea) - 1\r\n                || tile.x > this.cols - 1              \r\n                || playfield.board[tile.y][tile.x].active){\r\n                    return true;\r\n            }\r\n        }\r\n        return false;\r\n\r\n    }\r\n\r\n    shiftPiece(dir, p=this.activePiece){\r\n        if(p){\r\n            // try update\r\n            if(dir === \"left\") p.move(0,-1);\r\n            else if(dir === \"right\") p.move(0,1);\r\n            else if(dir === \"down\") p.move(1,0);\r\n\r\n            if(!this.collisionCheck(p, this.playfield)){\r\n                return true;\r\n            }\r\n\r\n            //revert\r\n            if(dir === \"left\") p.move(0,1);\r\n            else if(dir === \"right\") p.move(0,-1);\r\n            else if(dir === \"down\") p.move(-1,0);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    shiftInstant(dir, drop=false, p=this.activePiece){\r\n        if(p){\r\n            if(dir === \"left\") while(this.shiftPiece(\"left\", p)){\r\n                if(drop) this.shiftInstant(\"down\", drop, p);\r\n            }\r\n            else if(dir === \"right\") while(this.shiftPiece(\"right\", p)){\r\n                if(drop) this.shiftInstant(\"down\", drop, p);\r\n            }\r\n            else if(dir === \"down\") while(this.shiftPiece(\"down\", p)){}\r\n        }\r\n    }\r\n\r\n    rotateActive(x){\r\n        if(this.activePiece){\r\n            let oldRot = this.activePiece.rot;\r\n            let mod = (n, m) => ((n % m) + m) % m;\r\n            let newRot = mod(this.activePiece.rot + x, 4);\r\n            this.activePiece.rotate(newRot);\r\n\r\n            let kicks;\r\n            if(this.activePiece.name === \"i\") kicks = this.kickTable.i[oldRot][newRot];\r\n            else kicks = this.kickTable.n[oldRot][newRot]; \r\n\r\n            // TODO null check\r\n            if(kicks){\r\n                // try all kicks;\r\n                for (let i = 0; i < kicks.length; i++) {\r\n                    let kick = kicks[i];\r\n                    this.activePiece.move(-kick[1], kick[0]);\r\n\r\n                    if(!this.collisionCheck(this.activePiece, this.playfield)){\r\n                        return true;\r\n                    }\r\n\r\n                    // revert\r\n                    this.activePiece.move(kick[1], -kick[0]);\r\n                }\r\n            };\r\n\r\n            // revert\r\n            this.activePiece.rotate(oldRot);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    hardDrop(p=this.activePiece) {\r\n        if(p){\r\n            while(this.shiftPiece(\"down\", p)){}\r\n\r\n            this.playfield.write(this.activePiece)\r\n            this.playfield.clearLines();\r\n            this.queue.queueStep();\r\n            this.spawnPiece();\r\n        }\r\n    }\r\n\r\n    resetBoard() {\r\n        this.playfield.reset();\r\n        this.hold.setHold(\"\");\r\n        this.queue.reset();\r\n        this.history.reset();\r\n        this.spawnPiece();\r\n        // this.activePiece = new Piece(this.queue.getCurrent());\r\n    }\r\n\r\n    kickTable = {\r\n        // srs+ -- uses tetrio 180 kicks\r\n        n :{\r\n            0 : {\r\n                0 : [[0,0]],\r\n                1 : [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],\r\n                2 : [[0,0],[0,1],[1,1],[-1,1],[1,0],[-1,0]],\r\n                3 : [[0,0],[1,0],[1,1],[0,-2],[1,-2]],\r\n            },\r\n            1 : {\r\n                0 : [[0,0],[1,0],[1,-1],[0,2],[1,2]],\r\n                1 : [[0,0]],\r\n                2 : [[0,0],[1,0],[1,-1],[0,2],[1,2]],\r\n                3 : [[0,0],[1,0],[1,2],[1,1],[0,2],[0,1]],\r\n            },\r\n            2 : {\r\n                0 : [[0,0],[0,-1],[-1,-1],[1,-1],[-1,0],[1,0]],\r\n                1 : [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],\r\n                2 : [[0,0]],\r\n                3 : [[0,0],[1,0],[1,1],[0,-2],[1,-2]],\r\n            },\r\n            3 : {\r\n                0 : [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],\r\n                1 : [[0,0],[-1,0],[-1,2],[-1,1],[0,2],[0,1]],\r\n                2 : [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],\r\n                3 : [[0,0]],\r\n            },\r\n        },\r\n        // TODO: use better i kicks? check the wiki\r\n        i : {\r\n            0 : {\r\n                0 : [[0,0]],\r\n                1 : [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],\r\n                2 : [[0,0]],\r\n                3 : [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],\r\n            },\r\n            1 : {\r\n                0 : [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],\r\n                1 : [[0,0]],\r\n                2 : [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],\r\n                3 : [[0,0]],\r\n            },\r\n            2 : {\r\n                0 : [[0,0]],\r\n                1 : [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],\r\n                2 : [[0,0]],\r\n                3 : [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],\r\n            },\r\n            3 : {\r\n                0 : [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],\r\n                1 : [[0,0]],\r\n                2 : [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],\r\n                3 : [[0,0]],\r\n            },\r\n\r\n        }\r\n    }\r\n\r\n}\r\n\r\nclass Playfield {\r\n    constructor(rows=20, cols=10, tileSize=30, spawnArea=2, background=\"background\", canvas=\"field\"){\r\n        this.rows = rows;\r\n        this.cols = cols;\r\n        this.tileSize = tileSize;\r\n        this.spawnArea = spawnArea;\r\n\r\n        this.boardHeight = (rows+this.spawnArea)*tileSize;   \r\n        this.boardWidth = cols*tileSize;   \r\n\r\n        // initialize board\r\n        this.board = [];\r\n        for (let i = 0; i < this.rows+this.spawnArea; i++) {\r\n            let row = [];\r\n            for (let j = 0; j < this.cols; j++) {\r\n                row.push(new Tile(j,i));\r\n            }\r\n            this.board.push(row);\r\n        }\r\n\r\n        this.canvas = document.getElementById(canvas);\r\n        this.ctx = this.canvas.getContext(\"2d\");\r\n\r\n        this.backgroundCanvas = document.getElementById(background);\r\n        this.backgroundCtx = this.backgroundCanvas.getContext(\"2d\");\r\n    }\r\n\r\n    getData(){\r\n        let colors = Object.entries(Piece.pieces).map((e) => e[1].color).concat([\"#555555\"]);\r\n        let getColorIndex = (x) => {\r\n            for(const [i,c] of colors.entries()){\r\n                if(_utils_js__WEBPACK_IMPORTED_MODULE_0__.colorComp(c, x)){\r\n                    return i;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // board to bytes\r\n        let totalTiles = 22 * 10 // TODO fix magic number\r\n        let buffer = new ArrayBuffer(totalTiles, {maxByteLength: totalTiles})\r\n        let byteBoard = new Uint8Array(buffer);\r\n        let byteIndex = 0;\r\n\r\n        let repeat = 0;\r\n\r\n        for (let i = 0; i < totalTiles; i++) {\r\n            let tile = this.board[i%22][Math.floor(i/22)]; // TODO fix magic number\r\n            let tileData = 0;\r\n\r\n            if(tile.active || tile.ghost || tile.selected){\r\n                tileData = (tile.active << 7)\r\n                    | (tile.ghost << 6)\r\n                    | (tile.selected << 5)\r\n                    | (getColorIndex(tile.color) << 2);\r\n            }\r\n\r\n            if(byteIndex>=1 && tileData == byteBoard[byteIndex-1]){\r\n                repeat += 1;\r\n                if(i == totalTiles-1){\r\n                    // write repeat amount\r\n                    byteBoard[byteIndex-1] = byteBoard[byteIndex-1] | 1;  // flip repeat indicator bit\r\n                    byteBoard[byteIndex] = repeat;\r\n                    byteIndex += 1;\r\n                    repeat = 0;\r\n                }\r\n            }\r\n            else{\r\n                if(repeat){\r\n                    // write repeat amount\r\n                    byteBoard[byteIndex-1] = byteBoard[byteIndex-1] | 1;  // flip repeat indicator bit\r\n                    byteBoard[byteIndex] = repeat;\r\n                    byteIndex += 1;\r\n                    repeat = 0;\r\n                }\r\n\r\n                byteBoard[byteIndex] = tileData;\r\n                byteIndex += 1;\r\n            }\r\n\r\n        } \r\n\r\n        byteBoard.buffer.resize(byteIndex);\r\n\r\n        return byteBoard.buffer;\r\n    }\r\n\r\n    loadData(buffer){\r\n        this.reset();\r\n        let b = new Uint8Array(buffer);\r\n        let bIndex = 0;\r\n\r\n        let colors = Object.entries(Piece.pieces).map((e) => e[1].color).concat([\"#555555\"]);\r\n\r\n        let totalTiles = 22 * 10 // TODO fix magic number\r\n        let i = 0;\r\n\r\n        while(i < totalTiles){\r\n            if(b[bIndex] & 1){\r\n                let rNum = b[bIndex+1];\r\n                for(let r=0; r<rNum+1; r++){\r\n                    let tile = this.board[i%22][Math.floor(i/22)]; // TODO fix magic number\r\n                    let data = b[bIndex];\r\n                     \r\n                    tile.active = (data & 0x80) >> 7;\r\n                    tile.ghost = (data & 0x40) >> 6;\r\n                    tile.selected = (data & 0x20) >> 5;\r\n                    tile.color = colors[(data & 0x1c) >> 2]\r\n                    i += 1;\r\n                }\r\n                bIndex += 2;\r\n            }\r\n            else {\r\n                let tile = this.board[i%22][Math.floor(i/22)]; // TODO fix magic number\r\n                let data = b[bIndex];\r\n                    \r\n                tile.active = (data & 0x80) >> 7;\r\n                tile.ghost = (data & 0x40) >> 6;\r\n                tile.selected = (data & 0x20) >> 5;\r\n                tile.color = colors[(data & 0x1c) >> 2]\r\n                i += 1;\r\n                bIndex += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    setField(state){\r\n        this.board = state.playfield.copy().board;\r\n    }\r\n\r\n    getAllTiles(){\r\n        let tiles = [];\r\n        for (let i = 0; i < this.rows+this.spawnArea; i++) {\r\n            for (let j = 0; j < this.cols; j++) {\r\n                tiles.push(this.board[i][j]);\r\n            }\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    render(paused=false){\r\n        this.canvas.width = this.boardWidth;\r\n        this.canvas.height = this.boardHeight;\r\n\r\n        this.backgroundCanvas.width = this.boardWidth;\r\n        this.backgroundCanvas.height = this.boardHeight;\r\n\r\n        // clear \r\n        this.backgroundCtx.clearRect(0,0,this.canvas.width,this.canvas.height);\r\n        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\r\n\r\n        //spawn area\r\n        this.backgroundCtx.strokeStyle = \"black\";\r\n        this.backgroundCtx.globalAlpha = 0.6;\r\n        this.backgroundCtx.fillRect(0,0,this.canvas.width,this.spawnArea*this.tileSize);\r\n\r\n        // background + grid\r\n        this.backgroundCtx.globalAlpha = 1;\r\n        this.backgroundCtx.fillRect(0,this.spawnArea*this.tileSize,this.canvas.width,this.canvas.height);\r\n\r\n        // grid lines\r\n        this.backgroundCtx.strokeStyle = \"gray\";\r\n        this.backgroundCtx.globalAlpha = 0.25;\r\n        this.backgroundCtx.setLineDash([this.tileSize*0.25, this.tileSize*0.5, this.tileSize*0.25, 0]);\r\n        for (let i=this.spawnArea; i < this.rows+3; i++){\r\n            this.backgroundCtx.lineWidth = (i === this.spawnArea || i === this.rows+this.spawnArea) ? 1 : 2;\r\n            this.backgroundCtx.beginPath();\r\n            this.backgroundCtx.moveTo(0, i*(this.tileSize) )\r\n            this.backgroundCtx.lineTo(this.boardWidth, i*(this.tileSize));\r\n            this.backgroundCtx.stroke();\r\n        }\r\n        for (let i=0; i < this.cols+1; i++){\r\n            this.backgroundCtx.lineWidth = (i === 0 || i === this.cols) ? 1 : 2;\r\n            this.backgroundCtx.beginPath();\r\n            this.backgroundCtx.moveTo(i*(this.tileSize), this.spawnArea*this.tileSize)\r\n            this.backgroundCtx.lineTo(i*(this.tileSize), this.boardHeight);\r\n            this.backgroundCtx.stroke();\r\n        }\r\n        this.backgroundCtx.globalAlpha = 1;\r\n\r\n\r\n        // color board tiles\r\n        for (let row = 0; row < this.board.length; row++) {\r\n            for (let col = 0; col < this.board[row].length; col++) {\r\n                let tile = this.board[row][col]\r\n                if(tile){\r\n                    this.colorTile(tile);\r\n                }\r\n            }\r\n        }\r\n\r\n        //draw selection outlines\r\n        for (let row = 0; row < this.board.length; row++) {\r\n            for (let col = 0; col < this.board[row].length; col++) {\r\n                let tile = this.board[row][col]\r\n                if(tile){\r\n                    if(tile.selected){\r\n                        this.ctx.fillStyle = \"rgba(200,200,200, 1)\";\r\n                        this.ctx.fillRect((col*this.tileSize) - 2, (row*this.tileSize) - 2, this.tileSize+4, this.tileSize+4);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //clear inner\r\n        for (let row = 0; row < this.board.length; row++) {\r\n            for (let col = 0; col < this.board[row].length; col++) {\r\n                let tile = this.board[row][col]\r\n                if(tile){\r\n                    if(tile.selected){\r\n                        this.ctx.clearRect((col*this.tileSize), (row*this.tileSize), this.tileSize, this.tileSize);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        // redraw tiles\r\n        for (let row = 0; row < this.board.length; row++) {\r\n            for (let col = 0; col < this.board[row].length; col++) {\r\n                let tile = this.board[row][col]\r\n                if(tile && tile.selected){\r\n                    if(!(tile.active||tile.ghost)){\r\n                        this.ctx.clearRect((col*this.tileSize), (row*this.tileSize), this.tileSize, this.tileSize);\r\n                    }\r\n                    else{\r\n                        this.colorTile(tile);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(paused){\r\n            this.ctx.fillStyle = \"black\";\r\n            this.ctx.globalAlpha = 0.4;\r\n            this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);\r\n\r\n\r\n            //pause symbol\r\n            this.ctx.fillStyle = \"gray\";\r\n            this.ctx.globalAlpha = 0.6;\r\n            this.ctx.fillRect(this.canvas.width*0.5 - 30,this.canvas.height*0.5-30, 20, 60);\r\n            this.ctx.fillRect(this.canvas.width*0.5 + 10,this.canvas.height*0.5-30, 20, 60);\r\n        }\r\n\r\n    }\r\n\r\n    write(p){\r\n        // write piece to board\r\n        for (let i = 0; i < p.tiles.length; i++) {\r\n            let tile = p.tiles[i];\r\n            this.board[tile.y][tile.x].active = true;\r\n            this.board[tile.y][tile.x].color = p.color;\r\n        }\r\n    }\r\n\r\n    colorTile(tile, color=tile.color) {\r\n\r\n        if(tile.color){\r\n            if(tile.active){\r\n                this.ctx.fillStyle = color;\r\n            }\r\n            else if(tile.ghost){\r\n\r\n                let origColor = _utils_js__WEBPACK_IMPORTED_MODULE_0__.parseColor(color);\r\n                origColor.a = 0.4;\r\n                let ghostColor = \"rgba(\" + origColor.r + \",\" + origColor.g + \",\" + origColor.b + \",\" + origColor.a + \")\";\r\n\r\n                this.ctx.fillStyle = ghostColor;\r\n\r\n            }\r\n            else return;\r\n            this.ctx.clearRect(tile.x*this.tileSize, tile.y*this.tileSize, this.tileSize, this.tileSize);\r\n            this.ctx.fillRect(tile.x*this.tileSize, tile.y*this.tileSize, this.tileSize, this.tileSize);\r\n        }\r\n    }\r\n\r\n    isFull(row) {\r\n        for (let i=0; i < row.length; i++) {\r\n            if(!row[i].active) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    clearLines() {\r\n        let newBoard = [];\r\n        let cleared = 0;\r\n        // check lines from bottom up and adjust \r\n        for(let i=this.board.length-1; i>=0; i--){\r\n            let row = this.board[i];\r\n            if(this.isFull(row)){\r\n                cleared += 1;\r\n            }\r\n            else{\r\n                for(let j=0; j<row.length; j++){\r\n                    row[j].y += cleared;\r\n                }\r\n                newBoard.push(row)\r\n            }\r\n        }\r\n\r\n        let newLines = [];\r\n        for(let i=0; i<cleared; i++){\r\n            let row = [];\r\n            for (let j = 0; j < this.cols; j++) {\r\n                row.push(new Tile(j,i));\r\n            }\r\n            newLines.push(row);\r\n        }\r\n\r\n        this.board = [...newLines, ...(newBoard.reverse())];\r\n    }\r\n\r\n    reset() {\r\n        for (let row = 0; row < this.board.length; row++) {\r\n            for (let col = 0; col < this.board[row].length; col++) {\r\n                let tile = this.board[row][col];\r\n                tile.active = false;\r\n                tile.ghost = false;\r\n                tile.selected = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    copy(){\r\n        let copy = new Playfield(this.rows, this.cols, this.tileSize, this.spawnArea);\r\n\r\n        copy.board = [];\r\n        for (let i = 0; i < this.rows+this.spawnArea; i++) {\r\n            let row = [];\r\n            for (let j = 0; j < this.cols; j++) {\r\n                row.push(this.board[i][j].copy());\r\n            }\r\n            copy.board.push(row);\r\n        }\r\n\r\n        return copy;\r\n    }\r\n\r\n}\r\n\r\nclass Sketcher {\r\n    palette = [];\r\n\r\n    mouseRightDown = false;\r\n    mouseLeftDown = false;\r\n    shiftKey = false;\r\n    ctrlKey = false;\r\n    altKey = false;\r\n\r\n    drawColor = \"#555555\";\r\n    drawMode = false;\r\n    drawRectStart;\r\n\r\n    selected = [];\r\n    selectMode = true;\r\n    selectionOffsets = [];\r\n    selectRectStart;\r\n    // unselectFlag;\r\n\r\n    startDragTile;\r\n    dragBounds = {};\r\n    // dragBounds = {lowX: 0, \r\n    //     highX: this.playfield.cols-1, \r\n    //     lowY: 0,\r\n    //     highY: this.playfield.rows-1\r\n    // };\r\n\r\n    mode = null;\r\n\r\n    constructor(playfield, getActivePiece = ()=>{return null}, saveState= ()=>{}){\r\n        this.playfield = playfield;\r\n        this.canvas = this.playfield.canvas;\r\n        this.getActivePiece = getActivePiece;\r\n        this.saveState = saveState;\r\n\r\n        // intialize color palette\r\n\r\n        let paletteDiv = document.getElementById(\"palette\");\r\n        let colors = Object.entries(Piece.pieces).map((e) => e[1].color).concat([\"#555555\"]);\r\n\r\n        let i = 0\r\n        for (const c of colors) {\r\n            let color = document.createElement(\"div\");\r\n            color.id = \"color-\" + i;\r\n            color.style.background = c;\r\n            color.style.height = \"40px\";\r\n            color.style.width = \"40px\";\r\n            color.style.margin = \"10px\";\r\n            color.style.border = \"5px solid transparent\";\r\n            if(i == 7){\r\n                color.style.borderColor = \"white\";\r\n            }\r\n\r\n            paletteDiv.appendChild(color);\r\n            this.palette.push(color)\r\n\r\n            color.addEventListener('mousedown', (e) => {\r\n                this.drawColor = e.target.style.background;\r\n                this.updatePalette();\r\n            })\r\n            i++;\r\n        }\r\n\r\n\r\n        // handle events outside of canvas\r\n        document.addEventListener('mousedown',(e) => {\r\n            if(e.button == 0) this.mouseLeftDown = true; \r\n            if(e.button == 2) this.mouseRightDown = true; \r\n            this.shiftKey = e.shiftKey;\r\n            this.ctrlKey = e.ctrlKey;\r\n            this.altKey = e.altKey;\r\n        });\r\n        document.addEventListener('mouseup',(e) => {\r\n            if(e.button == 0) this.mouseLeftDown = false; \r\n            if(e.button == 2) this.mouseRightDown = false; \r\n            this.shiftKey = e.shiftKey;\r\n            this.ctrlKey = e.ctrlKey;\r\n            this.altKey = e.altKey;\r\n        });\r\n\r\n        // mouse logic\r\n        this.canvas.addEventListener('mousedown', (e) => {\r\n            this.shiftKey = e.shiftKey;\r\n            this.ctrlKey = e.ctrlKey;\r\n            this.altKey = e.altKey;\r\n            if(e.button == 0) this.mouseLeftDown = true; \r\n            if(e.button == 2) this.mouseRightDown = true; \r\n            let tile = this.getTile(e.offsetX, e.offsetY);\r\n            if(!tile) return;\r\n            if(e.button === 1){\r\n                // color picker\r\n                if(tile.active || tile.ghost){\r\n                    this.drawColor = tile.color;\r\n                    this.updatePalette();\r\n                }\r\n            }\r\n            else if(e.shiftKey || e.ctrlKey) {\r\n                this.mode = \"select\";\r\n                this.selectMode = !tile.selected;\r\n                if(this.mouseRightDown){\r\n                    this.selectRectStart = [tile.x, tile.y];\r\n                    this.selectRect(this.selectRectStart,[tile.x, tile.y], this.selectMode);\r\n                }\r\n                else this.select(tile, this.selectMode);\r\n            }\r\n            else if(tile.selected){\r\n                // start drag\r\n                // if(tile.selected){\r\n                    this.mode = \"drag\";\r\n                    this.startDragTile = tile;\r\n                    this.selected = this.playfield.getAllTiles().filter((t) => t.selected).map((t) => t.copy());\r\n                    this.selectionOffsets = this.selected.map((t) => {return {x: t.x - this.startDragTile.x, y: t.y - this.startDragTile.y}}, this);\r\n\r\n\r\n                    // compute bounds of drag\r\n                    let lowerX = Math.min(...this.selected.map((t) => t.x));\r\n                    let lowerY = Math.min(...this.selected.map((t) => t.y));\r\n                    let higherX = Math.max(...this.selected.map((t) => t.x));\r\n                    let higherY = Math.max(...this.selected.map((t) => t.y));\r\n\r\n                    this.dragBounds = {lowX: this.startDragTile.x-lowerX, \r\n                        highX: this.startDragTile.x+(this.playfield.cols-1)-higherX, \r\n                        lowY: this.startDragTile.y-lowerY,\r\n                        highY: this.startDragTile.y+(this.playfield.rows+this.playfield.spawnArea-1)-higherY\r\n                    };\r\n\r\n                    this.drag(tile);\r\n                // }\r\n                // else {\r\n                //     this.unselectFlag = true;\r\n                // }\r\n            }\r\n            else{ //draw\r\n                this.mode = \"draw\";\r\n                // this.drawMode = !tile.active || this.drawColor != tile.color;\r\n                this.drawMode = !(tile.active || tile.ghost);\r\n                tile.color = this.drawMode ? this.drawColor : null;\r\n                if(this.mouseRightDown){\r\n                    this.drawRectStart = [tile.x, tile.y];\r\n                    this.drawRect(this.drawRectStart,[tile.x, tile.y]);\r\n                }\r\n                else {\r\n                    this.draw(tile);\r\n                }\r\n            }\r\n        });\r\n        this.canvas.addEventListener('mousemove', (e) => {\r\n            let tile = this.getTile(e.offsetX, e.offsetY);\r\n            if(!tile) return;\r\n            if(this.mode === \"draw\"){\r\n                if(this.mouseRightDown){\r\n                    this.drawRect(this.drawRectStart,[tile.x, tile.y]);\r\n                }\r\n                else if(this.mouseLeftDown){\r\n                    this.draw(tile);\r\n                }\r\n            }\r\n            else if (this.mode === \"select\"){\r\n                if(this.mouseRightDown){\r\n                    this.selectRect(this.selectRectStart,[tile.x, tile.y], this.selectMode);\r\n                }\r\n                else if(this.mouseLeftDown){\r\n                    this.select(tile, this.selectMode);\r\n                }\r\n            }\r\n            else if (this.mode === \"drag\" && this.mouseLeftDown) {\r\n                this.drag(tile);\r\n            }\r\n        });\r\n        this.canvas.addEventListener('mouseup', (e) =>{\r\n            if(e.button == 0) this.mouseLeftDown = false; \r\n            if(e.button == 2) this.mouseRightDown = false; \r\n            let tile = this.getTile(e.offsetX, e.offsetY);\r\n            if(!tile) return;\r\n            if(this.mode === \"drag\"){\r\n                this.mode = \"select\";\r\n            }\r\n\r\n            this.saveState()\r\n        });\r\n\r\n        this.canvas.addEventListener('contextmenu', (e) => {e.preventDefault();e.stopPropagation();return false;}); // disable context menu\r\n        this.canvas.addEventListener('focusout', this.resetInputs); \r\n    }\r\n\r\n    // handleContextMenu(e) {\r\n    //     this.shiftKey = false;\r\n    //     e.preventDefault();\r\n    // }\r\n\r\n    resetInputs(e){\r\n        this.mouseLeftDown = false;\r\n        this.mouseRightDown = false;\r\n        this.shiftKey = false;\r\n        this.ctrlKey = false;\r\n        this.altKey = false;\r\n    }\r\n\r\n\r\n\r\n    getTile(xOffset,yOffset){\r\n        let tileX = Math.floor(xOffset / (this.playfield.tileSize));\r\n        let tileY = Math.floor(yOffset / (this.playfield.tileSize));\r\n\r\n        tileX = Math.min(tileX, this.playfield.cols - 1);\r\n        tileY = Math.min(tileY, (this.playfield.rows+this.playfield.spawnArea) - 1);\r\n\r\n        return this.playfield.board[tileY][tileX];\r\n    }\r\n\r\n    isInActivePiece(t){\r\n        let notActive = true;\r\n        let active = this.getActivePiece();\r\n        if(active){\r\n            for(let i=0; i<active.tiles.length; i++){\r\n                if(t.samePos(active.tiles[i])) return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    updatePalette() {\r\n\r\n        for (const c of this.palette) {\r\n            if(_utils_js__WEBPACK_IMPORTED_MODULE_0__.colorComp(this.drawColor, c.style.background)){\r\n                c.style.borderColor = \"white\";\r\n            }\r\n            else c.style.borderColor = \"transparent\";\r\n        }\r\n    }\r\n\r\n    draw(tile){\r\n        if(!this.isInActivePiece(tile)) {\r\n            tile.color = this.drawMode ? this.drawColor : null;\r\n            if(this.altKey && this.drawMode){\r\n                tile.ghost = this.drawMode;\r\n            }\r\n            else {\r\n                tile.active = this.drawMode;\r\n                tile.ghost = this.drawMode;\r\n                // tile.selected = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    drawRect(startPos, mousePos){\r\n        let startX = Math.min(startPos[0], mousePos[0]);\r\n        let startY = Math.min(startPos[1], mousePos[1]);\r\n        let endX = Math.max(startPos[0], mousePos[0]);\r\n        let endY = Math.max(startPos[1], mousePos[1]);\r\n\r\n        for(let row = startY; row<=endY; row++){\r\n            for(let col = startX; col<=endX; col++){\r\n                let tile = this.playfield.board[row][col];\r\n                this.draw(tile);\r\n\r\n\r\n\r\n                // tile.active = this.drawMode;\r\n                // // tile.selected = false;\r\n                // tile.color = this.drawMode ? this.drawColor : null;\r\n            }\r\n        }\r\n    }\r\n\r\n    select(tile, state=true){\r\n        // if(tile.active && this.shiftKey && this.mouseLeftDown){\r\n        if((this.shiftKey || this.ctrlKey) && (this.mouseLeftDown || this.mouseRightDown)){\r\n            tile.selected = state;\r\n        }\r\n    }\r\n\r\n    selectRect(startPos, mousePos, state){\r\n        let startX = Math.min(startPos[0], mousePos[0]);\r\n        let startY = Math.min(startPos[1], mousePos[1]);\r\n        let endX = Math.max(startPos[0], mousePos[0]);\r\n        let endY = Math.max(startPos[1], mousePos[1]);\r\n\r\n        for(let row = startY; row<=endY; row++){\r\n            for(let col = startX; col<=endX; col++){\r\n                let tile = this.playfield.board[row][col];\r\n                this.select(tile, state);\r\n            }\r\n        }\r\n    }\r\n\r\n    unselectAll(){\r\n        let tiles = this.playfield.getAllTiles();\r\n        for (let i=0; i<tiles.length; i++) {\r\n            let t = tiles[i];\r\n            t.selected = false;\r\n        }\r\n    }\r\n\r\n    // inDragBounds(tile){\r\n    //     return tile.x >= this.dragBounds.lowX \r\n    //         && tile.x <= this.dragBounds.highX \r\n    //         && tile.y >= this.dragBounds.lowY \r\n    //         && tile.y <= this.dragBounds.highY \r\n    // }\r\n\r\n    drag(curTile){\r\n        if(curTile !== this.startDragTile){\r\n\r\n            // let clamp = (x,lower,higher) => Math.max(Math.min(x, higher), lower);\r\n            let shiftX = _utils_js__WEBPACK_IMPORTED_MODULE_0__.clamp(curTile.x,  this.dragBounds.lowX, this.dragBounds.highX);\r\n            let shiftY = _utils_js__WEBPACK_IMPORTED_MODULE_0__.clamp(curTile.y,  this.dragBounds.lowY, this.dragBounds.highY);\r\n\r\n            // erase and update selected\r\n            for(let i=0; i<this.selected.length; i++){\r\n                let t = this.selected[i];\r\n                this.playfield.board[t.y][t.x].active = false;\r\n                this.playfield.board[t.y][t.x].selected = false;\r\n                this.playfield.board[t.y][t.x].ghost = false;\r\n            }\r\n\r\n            for(let i=0; i<this.selected.length; i++){\r\n                this.selected[i].x = shiftX + this.selectionOffsets[i].x;\r\n                this.selected[i].y = shiftY + this.selectionOffsets[i].y;\r\n                let copy = this.selected[i].copy();\r\n                this.playfield.board[copy.y][copy.x] = copy;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nclass Tile {\r\n    constructor(x,y, active=false, color=null) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.active = active;\r\n        this.color = color;\r\n        this.selected = false;\r\n        this.ghost = false;\r\n    }\r\n\r\n    samePos(t){\r\n        return (this.x === t.x) && (this.y === t.y);\r\n    }\r\n\r\n    copy() {\r\n        \r\n        let copy = new Tile(this.x, this.y, this.active, this.color);\r\n        copy.selected = this.selected;\r\n        copy.ghost = this.ghost;\r\n        return copy;\r\n    }\r\n\r\n    static isSame(a,b){\r\n        return a.x == b.x\r\n            & a.y == b.y\r\n            & a.active == b.active\r\n            & a.ghost == b.ghost\r\n            & a.selected == b.selected\r\n    }\r\n}\r\n\r\nclass Piece {\r\n    constructor(p, x=0, y=0, rot=0){\r\n        this.name = p;\r\n        this.pos = {x: x, y: y};\r\n        this.rot = rot;\r\n        this.offsets = Piece.pieces[this.name][this.rot];\r\n        this.color = Piece.pieces[this.name].color;\r\n        this.updateTiles();\r\n\r\n    }\r\n\r\n    copy() {\r\n        return new Piece(this.name, this.pos.x, this.pos.y, this.rot);\r\n    }\r\n\r\n    move(y, x){\r\n        this.pos.y += y;\r\n        this.pos.x += x;\r\n        this.updateTiles();\r\n    }\r\n\r\n    rotate(n){\r\n        this.rot = n;\r\n        this.offsets = Piece.pieces[this.name][this.rot];\r\n        this.updateTiles();\r\n    }\r\n\r\n    updateTiles(){\r\n        this.tiles = this.offsets.map((o) => {\r\n            return new Tile(this.pos.x+o[1], this.pos.y+o[0], true, this.color);\r\n        });\r\n    }\r\n\r\n    static pieces = {\r\n        i : {\r\n            0 : [[1,0],[1,1],[1,2],[1,3]],\r\n            1 : [[0,2],[1,2],[2,2],[3,2]],\r\n            2 : [[2,0],[2,1],[2,2],[2,3]],\r\n            3 : [[0,1],[1,1],[2,1],[3,1]],\r\n            color : \"#0f9bd7\"\r\n        },\r\n        j :{\r\n            0 : [[0,0],[1,0],[1,1],[1,2]],\r\n            1 : [[0,1],[0,2],[1,1],[2,1]],\r\n            2 : [[1,0],[1,1],[1,2],[2,2]],\r\n            3 : [[2,0],[2,1],[1,1],[0,1]],\r\n            color : \"#2141c6\"\r\n        },\r\n        l :{\r\n            0 : [[1,0],[1,1],[1,2],[0,2]],\r\n            1 : [[0,1],[1,1],[2,1],[2,2]],\r\n            2 : [[1,0],[1,1],[1,2],[2,0]],\r\n            3 : [[0,0],[2,1],[1,1],[0,1]],\r\n            color : \"#e35b02\"\r\n        },\r\n        o :{\r\n            0 : [[0,1],[0,2],[1,1],[1,2]],\r\n            1 : [[0,1],[0,2],[1,1],[1,2]],\r\n            2 : [[0,1],[0,2],[1,1],[1,2]],\r\n            3 : [[0,1],[0,2],[1,1],[1,2]],\r\n            color : \"#e39f02\"\r\n        },\r\n        s :{\r\n            0 : [[1,0],[1,1],[0,1],[0,2]],\r\n            1 : [[0,1],[1,1],[1,2],[2,2]],\r\n            2 : [[2,0],[2,1],[1,1],[1,2]],\r\n            3 : [[0,0],[1,0],[1,1],[2,1]],\r\n            color : \"#59b101\"\r\n        },\r\n        t :{\r\n            0 : [[0,1],[1,0],[1,1],[1,2]],\r\n            1 : [[0,1],[1,1],[1,2],[2,1]],\r\n            2 : [[1,0],[1,1],[1,2],[2,1]],\r\n            3 : [[0,1],[1,0],[1,1],[2,1]],\r\n            color : \"#af298a\"\r\n        },\r\n        z :{\r\n            0 : [[0,0],[0,1],[1,1],[1,2]],\r\n            1 : [[0,2],[1,1],[1,2],[2,1]],\r\n            2 : [[1,0],[1,1],[2,1],[2,2]],\r\n            3 : [[0,1],[1,1],[1,0],[2,0]],\r\n            color : \"#d70f37\"\r\n        },\r\n    }\r\n\r\n\r\n}\r\n\r\nclass Queue {\r\n    pieces = [\"i\", \"j\", \"l\", \"t\", \"s\", \"z\", \"o\"];\r\n    queue = [];\r\n    queueIndex = 0;\r\n    bagStarts = new Set();\r\n\r\n    slots = 6;\r\n    slotSizeY = 4;\r\n    slotSizeX = 6;\r\n    showMax = 6;\r\n\r\n    constructor(tileSize=25) {\r\n        this.canvas = document.getElementById(\"queue\");\r\n        this.ctx = this.canvas.getContext(\"2d\");\r\n        this.tileSize = tileSize;\r\n\r\n        this.queueHeight =  this.tileSize*this.slots*this.slotSizeY;\r\n        this.queueWidth =  this.tileSize*this.slotSizeX;\r\n\r\n        this.canvas.height = this.queueHeight;\r\n        this.canvas.width = this.queueWidth;\r\n\r\n        this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);\r\n\r\n        this.updateQueue();\r\n        this.renderQueue();\r\n    }\r\n\r\n    copy() {\r\n        let copy = new Queue(this.tileSize);\r\n        copy.queue = structuredClone(this.queue);\r\n        copy.queueIndex = this.queueIndex;\r\n        return copy;\r\n    }\r\n\r\n    renderQueue() {\r\n        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\r\n\r\n        for (let i = this.queueIndex+1; i < this.queueIndex+8; i++) {\r\n\r\n            if(i < this.queueIndex+this.showMax){\r\n                this.drawPiece(new Piece(this.queue[i]), this.tileSize, this.tileSize + (i-(this.queueIndex+1))*3*this.tileSize); // TODO better spacing ?\r\n            }\r\n\r\n            // dividers\r\n            this.ctx.lineWidth = 2;\r\n            this.ctx.strokeStyle = (i) % 7 == 6 ? \"rgba(200,200,200,0.5)\" : \"rgba(100,100,100,0.2)\" ;\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(this.queueWidth-20,(i-(this.queueIndex+1)+1)*3*this.tileSize+(this.tileSize/2))\r\n            this.ctx.lineTo(this.queueWidth,(i-(this.queueIndex+1)+1)*3*this.tileSize+(this.tileSize/2))\r\n            this.ctx.stroke();\r\n        }\r\n    }\r\n\r\n    drawPiece(p,x,y){\r\n\r\n        for(let i=0; i<p.offsets.length; i++){\r\n            let o = p.offsets[i];\r\n\r\n            let p1x = x + o[1]*this.tileSize;\r\n            let p1y = y + o[0]*this.tileSize;\r\n            this.ctx.fillStyle = p.color;\r\n            this.ctx.fillRect(p1x,p1y,this.tileSize,this.tileSize);\r\n        }\r\n    }\r\n\r\n    updateQueue(q=[]) {\r\n        //validate\r\n        // pieces = [\"i\", \"j\", \"l\", \"t\", \"s\", \"z\", \"o\"];\r\n        // for(let i=0; i<q.length; i++){\r\n        //     if(!Piece.pieces.includes(q[i])){\r\n        //         return false;\r\n        //     }\r\n        // }\r\n\r\n        if(q.length > 0){\r\n            this.queue = this.queue.slice(0,this.queueIndex);\r\n            this.queue = [...this.queue, ...q];\r\n        }\r\n\r\n        while (this.queue.length-this.queueIndex <= this.showMax) {\r\n            // Fisher Yates shuffle\r\n            let shuffle = (arr) => {\r\n                let copy = structuredClone(arr)\r\n                for (let i = copy.length - 1; i > 0; i--) {\r\n                    let j = Math.floor(Math.random() * (i + 1));\r\n                    [copy[i], copy[j]] = [copy[j], copy[i]];\r\n                }\r\n                return copy\r\n            }\r\n            this.queue.push(...shuffle(Object.entries(Piece.pieces).map((x) => x[0])));\r\n            // this.bagStarts.add(this.queue.length);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    setQueueIndex(i){\r\n        this.queueIndex = i;\r\n    }\r\n\r\n    queueStep(){\r\n        this.updateQueue();\r\n        this.queueIndex += 1;\r\n    }\r\n\r\n    getCurrent(){\r\n        return this.queue[this.queueIndex];\r\n    }\r\n\r\n    setCurrent(p){\r\n        this.queue[this.queueIndex] = p; \r\n    }\r\n\r\n    reset() {\r\n        this.queue = [];\r\n        this.queueIndex = 0;\r\n        this.updateQueue();\r\n    }\r\n\r\n}\r\n\r\n\r\nclass Hold {\r\n    pieceName;\r\n\r\n    constructor(tileSize=30) {\r\n\r\n        this.canvas = document.getElementById(\"hold\");\r\n        this.ctx = this.canvas.getContext(\"2d\");\r\n        this.tileSize = tileSize;\r\n\r\n        this.holdHeight =  this.tileSize*5;\r\n        this.holdWidth =  this.tileSize*6;\r\n\r\n        this.canvas.height = this.holdHeight;\r\n        this.canvas.width = this.holdWidth;\r\n\r\n        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\r\n\r\n        this.renderHold();\r\n    }\r\n\r\n    copy() {\r\n        let copy = new Hold(this.tileSize);\r\n        copy.pieceName = this.pieceName;\r\n        return copy;\r\n    }\r\n\r\n\r\n    renderHold(){\r\n        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\r\n        if(this.pieceName){\r\n            this.drawPiece(new Piece(this.pieceName), this.tileSize, this.tileSize); //TODO better spacing \r\n        }\r\n    }\r\n\r\n    drawPiece(p,x,y){\r\n        for(let i=0; i<p.offsets.length; i++){\r\n            let o = p.offsets[i];\r\n            let p1x = x + o[1]*this.tileSize;\r\n            let p1y = y + o[0]*this.tileSize;\r\n            this.ctx.fillStyle = p.color;\r\n            this.ctx.fillRect(p1x,p1y,this.tileSize,this.tileSize);\r\n        }\r\n    }\r\n    \r\n    getHold(){\r\n        return this.pieceName;\r\n    }\r\n    \r\n    setHold(n){\r\n        this.pieceName = n;\r\n    }\r\n\r\n}\r\n\r\n// class histNode{\r\n\r\n//     constructor(board=[], change=[], piece=''){\r\n//         this.board = board;\r\n//         this.change = change;\r\n//         this.piece = piece;\r\n\r\n//         this.parent;\r\n//         this.children = []\r\n//     }\r\n// }\r\n\r\nclass GameState {\r\n    \r\n    constructor(p){\r\n        this.playfieldData = null;\r\n        this.queueData = null;\r\n        this.holdData = null;\r\n\r\n        this.gameStateToString();\r\n    }\r\n\r\n    static gameStateToString(p){\r\n        /*\r\n         * Format: \r\n         *  queue (first byte for position, thenUint8Array stores 2 pieces) *   hold (1 byte) *   hold (1 byte)\r\n         *  hold (1 byte, points to position in queue)\r\n         *  board (Uint8Array, 2 bytes per tile)   \r\n         */\r\n\r\n\r\n        let colors = Object.entries(Piece.pieces).map((e) => e[1].color).concat([\"#555555\"]);\r\n        let getColorIndex = (x) => {\r\n            for(const [i,c] of colors.entries()){\r\n                if(_utils_js__WEBPACK_IMPORTED_MODULE_0__.colorComp(c, x)){\r\n                    return i;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // board to bytes\r\n        let totalTiles = 22 * 10 // TODO fix magic number\r\n        let byteBoard = new Uint8Array(totalTiles+1);\r\n\r\n        byteBoard[0] = 0;\r\n        foundActive = false;\r\n\r\n        for (let i = 0; i < totalTiles; i++) {\r\n            let tile = p.board[Math.floor(i/10)][i%10]; // TODO fix magic number\r\n\r\n            // assume board starts with many empty tiles store count in first byte\r\n            if(!foundActive && !(tile.active || tile.ghost || tile.selected)){\r\n                byteBoard[0] += 1;\r\n            }\r\n            else {\r\n                foundActive = true;\r\n                let tileData = (tile.active << 7)\r\n                    | (tile.ghost << 6)\r\n                    | (tile.selected << 5)\r\n                    | (getColorIndex(tile.color) << 2);\r\n\r\n            }\r\n\r\n\r\n\r\n\r\n            if(tile.active || tile.ghost || tile.selected) {\r\n                let posByte = i;\r\n                let infoByte = (tile.active << 7)\r\n                    | (tile.ghost << 6)\r\n                    | (tile.selected << 5)\r\n                    | (getColorIndex(tile.color) << 2);\r\n                // console.log(byte.toString(2).padStart(16, '0'))\r\n                byteBoard[size] = posByte;\r\n                byteBoard[size+1] = infoByte;\r\n                size += 2;\r\n            }\r\n            // console.log(String(byte.toString(2)).padStart(8, '0'));\r\n        }\r\n\r\n        byteBoard = byteBoard.subarray(0,size);\r\n\r\n        //convert to base-64 string\r\n        let s = \"\";\r\n\r\n        for(let i=0; i < byteBoard.length; i++){\r\n            // console.log(byteBoard[i].toString(2).padStart(8,'0'))\r\n            s += String.fromCharCode(byteBoard[i]);\r\n        }\r\n        console.log(s);\r\n        console.log(window.btoa(s));\r\n\r\n\r\n        return window.btoa(s);\r\n    }\r\n\r\n    static stringToGameState(s){\r\n\r\n        //decode string\r\n        let decoded = window.atob(s);\r\n\r\n\r\n        //build board\r\n        let b = new Uint8Array(decoded.length);\r\n        for(let i=0; i<decoded.length; i++){\r\n            b[i] = decoded.charCodeAt(i);\r\n        }\r\n\r\n        console.log(\"b length:\", b.length);\r\n\r\n        return b.buffer;\r\n\r\n        let p = new Playfield();\r\n        p.loadData(b.buffer)\r\n\r\n        return p;\r\n    }\r\n\r\n}\r\n\r\nclass BoardHistory {\r\n    states = []\r\n    stateIndex = null;\r\n\r\n\r\n    // constructor(){\r\n    //     this.statesRoot = new histNode(); \r\n    // }\r\n    \r\n    // static stateToString(state){\r\n    //     //build bitBoards\r\n    //     let colors = Object.entries(Piece.pieces).map((e) => e[1].color).concat([\"#555555\"]);\r\n    //     let bitBoards = []\r\n    //     for( let row of state.playfield.board){\r\n    //         for(let t of row){\r\n    //             for(let i=0; i<colors.length; i++){\r\n    //                 if(bitBoards.length < colors.length){\r\n    //                     bitBoards.push(\"\")\r\n    //                 }\r\n    //                 if(t.active && Sketcher.colorComp(t.color, colors[i])){\r\n    //                     bitBoards[i] += '1';\r\n    //                 }\r\n    //                 else bitBoards[i] += '0';\r\n    //             }\r\n    //         }\r\n    //     }\r\n\r\n    //     // convert to BigInts\r\n    //     let boards = [];\r\n    //     for(const b of bitBoards){\r\n    //         boards.push(BigInt(\"0b\" + b))\r\n    //     }\r\n\r\n    //     let c = BigInt(0);\r\n    //     for (const b of boards){\r\n    //         c = c | b;\r\n    //     }\r\n    //     // console.log(c)\r\n\r\n    // }\r\n\r\n\r\n\r\n\r\n    addState(playfield, queue, hold){\r\n        // overwrite states in front if in past\r\n        if(this.stateIndex < this.states.length-1){\r\n            this.states = this.states.slice(0,this.stateIndex+1);\r\n        }\r\n\r\n        let state = {playfield: playfield, \r\n                    queue: queue,\r\n                    hold: hold}\r\n        this.states.push(state);\r\n\r\n        if(this.stateIndex !== null) {\r\n            this.stateIndex += 1;\r\n        }\r\n        else this.stateIndex = 0;\r\n    }\r\n\r\n    getState(n=0){\r\n        if(this.stateIndex !== null){\r\n            this.stateIndex = Math.max(Math.min(this.stateIndex + n, this.states.length-1 ),0)  ;\r\n            return this.states[this.stateIndex];\r\n        }\r\n    }\r\n\r\n    reset() {\r\n        this.states = [];\r\n        this.stateIndex = null;\r\n    }\r\n}\r\n\r\nclass InputManager {\r\n    keysDown = {};\r\n    lastKey = null;\r\n\r\n    constructor(callback) {\r\n        // this.timer = new Worker(\"timer.js\");\r\n        window.addEventListener(\"keydown\", (e) => this.keyDown(e));\r\n        window.addEventListener(\"keyup\", (e) => this.keyUp(e));\r\n\r\n        document.getElementById(\"field\").addEventListener('focusout', this.resetInputs); \r\n\r\n        this.callback = callback;\r\n    }\r\n\r\n    resetInputs(e){\r\n        this.keysDown = {};\r\n        this.lastKey = null;\r\n    }\r\n\r\n    keyDown(e) {\r\n        if(!this.keysDown[e.key]) {\r\n            this.keysDown[e.key] = performance.now();\r\n            this.lastKey = e.key;\r\n            this.callback(e.key, true);\r\n        }\r\n    }\r\n\r\n    keyUp(e) {\r\n        this.keysDown[e.key] = null;\r\n        this.callback(e.key, false);\r\n    }\r\n\r\n}\r\n\r\nclass Settings{\r\n    // gravity = 1000;\r\n\r\n    // Max's settings\r\n    // das = 100;\r\n    // arr = 0;\r\n    // softDrop = 0;\r\n    // keybinds = {\r\n    //     leftKey: 's',\r\n    //     rightKey: 'f',\r\n    //     softKey: 'd',\r\n    //     hardKey: 'j',\r\n    //     holdKey: 'e',\r\n    //     crKey: 'l',\r\n    //     ccrKey: 'k',\r\n    //     r180Key: ';',\r\n    //     restartKey: 'r',\r\n    //     undoKey: 'z',\r\n    //     redoKey: 'a',\r\n    // };\r\n\r\n    // Default Settings\r\n    das = 130;\r\n    arr = 50;\r\n    softDrop = 20;\r\n    keybinds = {\r\n        leftKey: 'ArrowLeft',\r\n        rightKey: 'ArrowRight',\r\n        softKey: 'ArrowDown',\r\n        hardKey: ' ',\r\n        holdKey: 'c',\r\n        crKey: 'ArrowUp',\r\n        ccrKey: 'z',\r\n        r180Key: 'a',\r\n        restartKey: 'r',\r\n        undoKey: 'q',\r\n        redoKey: 'w',\r\n        // spinKey: 'a',\r\n    };\r\n\r\n    constructor(input, pauseInput, resumeInput, board){\r\n        this.input = input;\r\n        this.pause = pauseInput;\r\n        this.resume = resumeInput;\r\n        this.board = board;\r\n\r\n        this.loadSettings();\r\n\r\n        let s = document.getElementById(\"settings\")\r\n        \r\n        s.addEventListener(\"focusin\", (e) => this.pause());\r\n        s.addEventListener(\"focusout\", (e) => this.resume());\r\n\r\n        s.innerHTML = \"\";\r\n\r\n        let html = \"\";\r\n        // html += \"<button onclick=\\\"game.startGame()\\\"> New game </button>\";\r\n\r\n        // queue\r\n        html += \"<div class=\\\"setting\\\"><p>update queue</p><input id=\\\"queueUpdate\\\"></input></div>\";\r\n\r\n        // timing\r\n        html += \"<div id=\\\"timing\\\">\"\r\n        for(const [k, v] of Object.entries(this)){\r\n            if(k === \"das\" || k === \"arr\" || k === \"softDrop\"){\r\n                html += \"<div class=\\\"setting\\\">\";\r\n                html += \"<p id=\\\"\" + k + \"Text\" + \"\\\">\" + k + \" (ms)\" +  \" : \" + v + \"</p>\";\r\n                html += \"<input id=\\\"\" + k + \"Field\" + \"\\\">\" + \"</input>\";\r\n                html += \"</div>\";\r\n            }\r\n        }\r\n        html += \"</div>\"\r\n\r\n        html += \"<div id=\\\"keyBinds\\\">\"\r\n        html += \"<button id=\\\"changeAll\\\"> Change All Keybinds</button>\"\r\n        for(const [k, v] of Object.entries(this.keybinds)){\r\n            html += \"<div class=\\\"setting\\\">\";\r\n            html += \"<p id=\\\"\" + k + \"Text\" + \"\\\" >\" + k + \" : </p>\"\r\n            html += \"<p id=\\\"\" + k + \"\\\">\" + (v === \" \" ? \"Space\" : v) + \"</p>\";\r\n            html += \"<button id =\\\"\" + k + \"Button\\\">change</button>\"\r\n            html += \"</div>\";\r\n        }\r\n        html += \"</div>\"\r\n        document.getElementById(\"settings\").innerHTML += html;\r\n\r\n        // add listeners\r\n        document.getElementById(\"queueUpdate\").addEventListener(\"keyup\", (e) => {\r\n            if(e.key === \"Enter\"){\r\n                let newQ = document.getElementById(\"queueUpdate\").value.toLowerCase().split(\"\");\r\n\r\n                // validate\r\n                let pieces = [\"i\", \"j\", \"l\", \"t\", \"s\", \"z\", \"o\"];\r\n                for(let i=0; i<newQ.length; i++){\r\n                    if(!pieces.includes(newQ[i])){\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                this.board.queue.updateQueue(newQ);\r\n                this.board.hold.setHold(null);\r\n                document.getElementById(\"queueUpdate\").value = \"\";\r\n                document.getElementById(\"queueUpdate\").blur();\r\n            }\r\n        })\r\n\r\n\r\n        for(const [k, v] of Object.entries(this)){\r\n            if(k === \"das\" || k === \"arr\" || k === \"softDrop\"){\r\n                document.getElementById(k + \"Field\").addEventListener(\"keyup\", (e) => {\r\n                    if(e.key === \"Enter\"){\r\n                        this.update(k, document.getElementById(k+\"Field\").value);\r\n                        document.getElementById(k+\"Field\").value = \"\";\r\n                        document.getElementById(k+\"Field\").blur();\r\n                    }\r\n                })\r\n            }\r\n        }\r\n\r\n        document.getElementById(\"changeAll\").addEventListener(\"click\", (e) => this.changeAllKeys());\r\n\r\n        for(const [k, v] of Object.entries(this.keybinds)){\r\n            document.getElementById(k+\"Button\").addEventListener(\"click\", (e) => {\r\n                document.getElementById(k+\"Button\").blur(); // needed to make sure spacebar doesn't retrigger button\r\n                this.updateKey(k);\r\n            })\r\n        }\r\n\r\n    }\r\n    \r\n    loadSettings() {\r\n        let cookieSettingsRaw = decodeURIComponent(document.cookie).split(\"; \").find((row) => row.startsWith(\"settings=\"));\r\n        if(cookieSettingsRaw){\r\n            let cookieSettings = JSON.parse(cookieSettingsRaw.split(\"=\")[1]);\r\n            this.das = cookieSettings.das;\r\n            this.arr = cookieSettings.arr;\r\n            this.softDrop = cookieSettings.softDrop;\r\n            this.keybinds = cookieSettings.keybinds;\r\n\r\n            //close settings pane\r\n            let s = document.getElementById(\"settings\")\r\n\r\n            // let tl1 = gsap.timeline();\r\n            // tl1.to(\"#settingsExpandWrapper\" , {\r\n            //     scaleX: 0,\r\n            //     duration: 1,\r\n            //     ease: \"none\",\r\n            // });\r\n\r\n\r\n            // let tl2 = gsap.timeline();\r\n            //     tl2.to(\"#settings\", {\r\n            //     x: 400,\r\n            //     duration: 1,\r\n            //     // ease: \"none\",\r\n            // });\r\n\r\n        }\r\n    }\r\n\r\n    saveSettings() {\r\n        let cookie = {\r\n            das : this.das,\r\n            arr : this.arr,\r\n            softDrop : this.softDrop,\r\n            keybinds : this.keybinds\r\n        }\r\n\r\n        let x = new Date();\r\n        x.setTime(x.getTime() + 24*60*60*365*1000); // 1 year;\r\n        \r\n        document.cookie = \"settings=\" + encodeURIComponent(JSON.stringify(cookie))\r\n                            + \"; expires=\" + x.toUTCString();\r\n\r\n    }\r\n\r\n    removeFocus() {\r\n        document.getElementById(\"queueUpdate\").blur();\r\n    }\r\n\r\n    updateDisplay(){\r\n        for(const [k, v] of Object.entries(this)){\r\n            if(k === \"das\" || k === \"arr\" || k === \"softDrop\"){\r\n                document.getElementById(k+\"Text\").innerHTML = k + \" (ms) : \" + v;\r\n            }\r\n        }\r\n\r\n        for(const [k, v] of Object.entries(this.keybinds)){\r\n            document.getElementById(k).innerHTML = (v === \" \" ? \"Space\" : v);\r\n        }\r\n\r\n        this.saveSettings();\r\n    }\r\n\r\n    async changeAllKeys(){\r\n        for(const [k, v] of Object.entries(this.keybinds)){\r\n            document.getElementById(k).innerHTML = \"Waiting...\";\r\n            let newKey = await this.awaitKey();\r\n            this.keybinds[k] = newKey;\r\n            this.updateDisplay();\r\n        }\r\n        document.getElementById(\"changeAll\").blur(); // needed to make sure spacebar doesn't retrigger button\r\n    }\r\n\r\n    update(s, newVal){\r\n        this[s] = parseInt(newVal);\r\n        this.updateDisplay();\r\n    }\r\n\r\n    async updateKey(k){\r\n        this.pause();\r\n        document.getElementById(k).innerHTML = \"Waiting...\";\r\n\r\n        let newKey = await this.awaitKey();\r\n        this.keybinds[k] = newKey;\r\n\r\n        this.resume();\r\n        this.updateDisplay();\r\n    }\r\n\r\n    awaitKey() {\r\n        let waitKey = new Promise((resolve) => {\r\n            document.addEventListener(\"keydown\", (e) => {\r\n                e.preventDefault();\r\n                resolve(e.key);\r\n                }, {once: true}\r\n            )\r\n        })\r\n        return waitKey;\r\n    }\r\n}\r\n\r\nclass Paster {\r\n    active = false;\r\n    dragging = null;\r\n\r\n\r\n    highlightSlider = null;\r\n    sliderLen = 40;\r\n    sliderWid = 10;\r\n    sliderColor = \"rgba(150,150,150,1)\"\r\n    sliderHighlightColor = \"rgba(220,220,220,1)\"\r\n    \r\n    constructor() {\r\n        this.preview = new Playfield(20, 10, 30, 2, \"previewBackground\", \"previewField\");\r\n        // this.sketcher = new Sketcher(this.preview);\r\n\r\n        this.imgCanvas = document.getElementById(\"imageCanvas\");\r\n        this.imgCanvas.width = window.innerWidth * 0.4;\r\n        this.imgCanvas.height = window.innerHeight * 0.8;\r\n        this.imgCtx = this.imgCanvas.getContext(\"2d\");\r\n        this.imgBounds = {p1:{x:0,y:0},p2:{x:this.imgCanvas.width,y:this.imgCanvas.height}}\r\n\r\n        this.ctrlsCanvas = document.getElementById(\"imageControls\");\r\n        this.ctrlsCanvas.width = window.innerWidth * 0.4;\r\n        this.ctrlsCanvas.height = window.innerHeight * 0.8;\r\n        this.ctrlsCtx = this.ctrlsCanvas.getContext(\"2d\");\r\n\r\n        // this.left = this.sliderWid/2;\r\n        // this.top = this.sliderWid/2;\r\n        // this.right = this.imgCanvas.width - this.sliderWid/2;\r\n        // this.bottom = this.imgCanvas.height - this.sliderWid/2;\r\n\r\n\r\n        // handle pasted images\r\n        document.addEventListener(\"paste\", (e) => {\r\n            this.openModal();\r\n\r\n            // load image\r\n            if (e.clipboardData.files.length > 0) {\r\n                let file = e.clipboardData.files[0]\r\n                let reader = new FileReader();\r\n                reader.onload = (e) => {\r\n                    this.img = new Image();\r\n                    this.img.onload = () => {\r\n                        let ratio = Math.min(this.imgCanvas.width / this.img.width, this.imgCanvas.height / this.img.height);\r\n                        let newWidth = this.img.width * ratio;\r\n                        let newHeight = this.img.height * ratio;\r\n                        let x = (this.imgCanvas.width/2) - (newWidth/2);\r\n                        let y = (this.imgCanvas.height/2) - (newHeight/2);\r\n                        this.imgBounds = {p1:{x:x,y:y},p2:{x:x+newWidth,y:y+newHeight}};\r\n\r\n                        this.top = Math.max(this.sliderWid/2, this.imgBounds.p1.y);\r\n                        this.bottom = Math.min(this.imgCanvas.height - this.sliderWid/2, this.imgBounds.p2.y);\r\n                        this.left = Math.max(this.sliderWid/2, this.imgBounds.p1.x);\r\n                        this.right = Math.min(this.imgCanvas.width - this.sliderWid/2, this.imgBounds.p2.x);\r\n\r\n\r\n                        this.update();\r\n                        this.render();\r\n                        // console.log(\"done\");\r\n                    };\r\n                    this.img.src = e.target.result;\r\n                }\r\n                reader.readAsDataURL(file);\r\n            }\r\n        })\r\n\r\n\r\n        // mouse event listeners\r\n        this.ctrlsCanvas.addEventListener(\"mousedown\", (e) => {\r\n\r\n\r\n            if(Math.abs(e.offsetX - (this.left+(this.right-this.left)/2)) < this.sliderLen+5 && \r\n                    Math.abs(e.offsetY - this.top) < this.sliderWid+5){\r\n                this.dragging = \"top\";\r\n                this.highlight = \"top\";\r\n                this.top = _utils_js__WEBPACK_IMPORTED_MODULE_0__.clamp(e.offsetY, this.sliderWid/2, this.bottom - this.sliderWid);\r\n            }\r\n            else if(Math.abs(e.offsetX - (this.left+(this.right-this.left)/2)) < this.sliderLen+5 && \r\n                    Math.abs(e.offsetY - this.bottom) < this.sliderWid+5){\r\n                this.dragging = \"bottom\";\r\n                this.highlight = \"bottom\";\r\n                this.bottom = _utils_js__WEBPACK_IMPORTED_MODULE_0__.clamp(e.offsetY, this.top+this.sliderWid, this.imgCanvas.height-this.sliderWid/2);\r\n            }\r\n            else if(Math.abs(e.offsetY - (this.top+(this.bottom-this.top)/2)) < this.sliderLen+5 && \r\n                    Math.abs(e.offsetX - this.left) < this.sliderWid+5){\r\n                this.dragging = \"left\";\r\n                this.highlight = \"left\";\r\n                this.left = _utils_js__WEBPACK_IMPORTED_MODULE_0__.clamp(e.offsetX, this.sliderWid/2, this.right-this.sliderWid);\r\n            }\r\n            else if(Math.abs(e.offsetY - (this.top+(this.bottom-this.top)/2)) < this.sliderLen+5 && \r\n                    Math.abs(e.offsetX - this.right) < this.sliderWid+5){\r\n                this.dragging = \"right\";\r\n                this.highlight = \"right\";\r\n                this.right = _utils_js__WEBPACK_IMPORTED_MODULE_0__.clamp(e.offsetX, this.left+this.sliderWid, this.imgCanvas.width - this.sliderWid/2);\r\n            }\r\n        });\r\n\r\n        this.ctrlsCanvas.addEventListener(\"mousemove\", (e) => {\r\n            if(this.dragging == \"top\" ||\r\n                    (Math.abs(e.offsetX - (this.left+(this.right-this.left)/2)) < this.sliderLen+5 && \r\n                    Math.abs(e.offsetY - this.top) < this.sliderWid+5)){\r\n                this.highlight = \"top\";\r\n            }\r\n            else if(this.dragging == \"bottom\" ||\r\n                    (Math.abs(e.offsetX - (this.left+(this.right-this.left)/2)) < this.sliderLen+5 && \r\n                    Math.abs(e.offsetY - this.bottom) < this.sliderWid+5)){\r\n                this.highlight = \"bottom\";\r\n            }\r\n            else if(this.dragging == \"left\" ||\r\n                    (Math.abs(e.offsetY - (this.top+(this.bottom-this.top)/2)) < this.sliderLen+5 && \r\n                    Math.abs(e.offsetX - this.left) < this.sliderWid+5)){\r\n                this.highlight = \"left\";\r\n            }\r\n            else if(this.dragging == \"right\" ||\r\n                    (Math.abs(e.offsetY - (this.top+(this.bottom-this.top)/2)) < this.sliderLen+5 && \r\n                    Math.abs(e.offsetX - this.right) < this.sliderWid+5)){\r\n                this.highlight = \"right\";\r\n            }\r\n            else this.highlight = null;\r\n\r\n            if(this.dragging) this.update();\r\n            if(this.dragging == \"top\"){\r\n                this.top = _utils_js__WEBPACK_IMPORTED_MODULE_0__.clamp(e.offsetY, this.sliderWid/2, this.bottom - this.sliderWid);\r\n            }\r\n            else if(this.dragging == \"bottom\"){\r\n                this.bottom = _utils_js__WEBPACK_IMPORTED_MODULE_0__.clamp(e.offsetY, this.top+this.sliderWid, this.imgCanvas.height-this.sliderWid/2);\r\n            }\r\n            else if(this.dragging == \"left\"){\r\n                this.left = _utils_js__WEBPACK_IMPORTED_MODULE_0__.clamp(e.offsetX, this.sliderWid/2, this.right-this.sliderWid);\r\n            }\r\n            else if(this.dragging == \"right\"){\r\n                this.right = _utils_js__WEBPACK_IMPORTED_MODULE_0__.clamp(e.offsetX, this.left+this.sliderWid, this.imgCanvas.width - this.sliderWid/2);\r\n            }\r\n        });\r\n\r\n        document.addEventListener(\"mouseup\", (e) => {\r\n            if(this.dragging){\r\n                this.update();\r\n            }\r\n            this.dragging = null;\r\n        });\r\n\r\n        document.getElementById(\"modalOverlay\").addEventListener(\"mousedown\", (e) => {\r\n            this.closeModal();\r\n        });\r\n        \r\n        document.getElementById(\"modal\").addEventListener(\"mousedown\", (e) => {\r\n            e.stopPropagation();\r\n        });\r\n\r\n    }\r\n\r\n    update() {\r\n        // for(let i = this.preview.spawnArea; i < this.preview.rows + this.preview.spawnArea; i++ ){\r\n        //     for(let j = 0; j < this.preview.cols; j++ ){\r\n        //         let newTileSize = [((this.right-this.left)/this.preview.cols)/2, ((this.bottom-this.top)/this.preview.rows)/2];\r\n\r\n        //         let x = this.left + ((this.right-this.left)/this.preview.cols)*j + newTileSize[0]/2;\r\n        //         let y = this.top + ((this.bottom-this.top)/this.preview.rows-this.preview.spawnArea)*i + newTileSize[1]/2;\r\n\r\n        for(let i = 0; i < this.preview.rows; i++ ){\r\n            for(let j = 0; j < this.preview.cols; j++ ){\r\n                let newTileSize = [(this.right-this.left)/this.preview.cols, (this.bottom-this.top)/(this.preview.rows)];\r\n                let tile = this.preview.board[i+this.preview.spawnArea][j];\r\n\r\n                let x = this.left + newTileSize[0]*j + newTileSize[0]/2;\r\n                let y = this.top + newTileSize[1]*i + newTileSize[1]/2;\r\n\r\n\r\n                let pixColor = _utils_js__WEBPACK_IMPORTED_MODULE_0__.parseColor(this.getPixelColor(x,y));\r\n                let colors = Object.entries(Piece.pieces).map((e) => e[1].color).concat([\"#555555\",\"#000000\"]);\r\n\r\n\r\n                if(pixColor.r + pixColor.g + pixColor.b < 50 || pixColor.a == 0){\r\n                    tile.active = false;\r\n                }\r\n                else {\r\n                    tile.color = this.getPixelColor(x,y);\r\n                    tile.active = true;\r\n                }\r\n\r\n\r\n                // console.log(' ')\r\n                // let bestMatch = null;\r\n                // let bestDelta = null;\r\n                // for(const c of colors){\r\n                //     let delta = utils.deltaE(pixColor, utils.parseColor(c));\r\n                //     // console.log(c, delta);\r\n                //     if(!bestMatch || bestDelta > delta){\r\n                //         bestMatch = c;\r\n                //         bestDelta = delta\r\n                //     }\r\n                // }\r\n\r\n                // if(bestMatch == \"#000000\" || pixColor.a == 0){\r\n                //     tile.active = false;\r\n                // }\r\n                // else {\r\n                //     tile.color = bestMatch;\r\n                //     tile.active = true;\r\n                // }\r\n            }\r\n        }\r\n    }\r\n\r\n    render(){\r\n        if(this.active && this.img){\r\n            this.preview.render();\r\n\r\n            this.imgCtx.clearRect(0,0,this.imgCanvas.width,this.imgCanvas.height);\r\n            this.imgCtx.drawImage(this.img, this.imgBounds.p1.x, this.imgBounds.p1.y, \r\n                this.imgBounds.p2.x-this.imgBounds.p1.x,\r\n                this.imgBounds.p2.y-this.imgBounds.p1.y);\r\n\r\n            // draw sliders\r\n            this.ctrlsCtx.clearRect(0,0,this.imgCanvas.width,this.imgCanvas.height);\r\n            this.ctrlsCtx.fillStyle = \"rgba(26,26,36,0.5)\"\r\n            this.ctrlsCtx.fillRect(0,0,this.imgCanvas.width,this.top);\r\n            this.ctrlsCtx.fillRect(0,this.bottom, this.imgCanvas.width, this.imgCanvas.height);\r\n            this.ctrlsCtx.fillRect(0,this.top,this.left, this.bottom-this.top);\r\n            this.ctrlsCtx.fillRect(this.right,this.top,this.imgCanvas.width, this.bottom-this.top);\r\n\r\n            this.ctrlsCtx.strokeStyle = \"white\";\r\n            this.ctrlsCtx.setLineDash([10,10]) \r\n            this.ctrlsCtx.beginPath();\r\n            this.ctrlsCtx.moveTo(0,this.top)\r\n            this.ctrlsCtx.lineTo(this.imgCanvas.width, this.top);\r\n            this.ctrlsCtx.moveTo(0,this.bottom)\r\n            this.ctrlsCtx.lineTo(this.imgCanvas.width, this.bottom);\r\n            this.ctrlsCtx.moveTo(this.left,0)\r\n            this.ctrlsCtx.lineTo(this.left, this.imgCanvas.height);\r\n            this.ctrlsCtx.moveTo(this.right,0)\r\n            this.ctrlsCtx.lineTo(this.right, this.imgCanvas.height);\r\n            this.ctrlsCtx.stroke();\r\n            this.ctrlsCtx.setLineDash([]) \r\n\r\n            this.ctrlsCtx.fillStyle = this.highlight == \"top\" ? this.sliderHighlightColor : this.sliderColor; \r\n            this.ctrlsCtx.fillRect((this.left+((this.right-this.left)/2))-(this.sliderLen/2),this.top-(this.sliderWid/2),this.sliderLen,this.sliderWid);\r\n            this.ctrlsCtx.fillStyle = this.highlight == \"bottom\" ? this.sliderHighlightColor : this.sliderColor; \r\n            this.ctrlsCtx.fillRect((this.left+((this.right-this.left)/2))-(this.sliderLen/2),this.bottom-(this.sliderWid/2),this.sliderLen,this.sliderWid);\r\n            this.ctrlsCtx.fillStyle = this.highlight == \"left\" ? this.sliderHighlightColor : this.sliderColor; \r\n            this.ctrlsCtx.fillRect(this.left-(this.sliderWid/2),(this.top+((this.bottom-this.top)/2))-(this.sliderLen/2),this.sliderWid,this.sliderLen);\r\n            this.ctrlsCtx.fillStyle = this.highlight == \"right\" ? this.sliderHighlightColor : this.sliderColor; \r\n            this.ctrlsCtx.fillRect(this.right-(this.sliderWid/2),(this.top+((this.bottom-this.top)/2))-(this.sliderLen/2),this.sliderWid,this.sliderLen);\r\n\r\n\r\n            // this.ctrlsCtx.fillStyle = \"green\";\r\n            // this.ctrlsCtx.ellipse(100,100,20,20,0,0,0);\r\n            // this.ctrlsCtx.beginPath();\r\n            // this.ctrlsCtx.arc(100, 100, 50, 0, 2 * Math.PI);\r\n            // this.ctrlsCtx.fill();\r\n\r\n\r\n            // draw dots\r\n            for(let i = 0; i < this.preview.rows; i++ ){\r\n                for(let j = 0; j < this.preview.cols; j++ ){\r\n                    let newTileSize = [(this.right-this.left)/this.preview.cols, (this.bottom-this.top)/(this.preview.rows)];\r\n\r\n                    let x = this.left + newTileSize[0]*j + newTileSize[0]/2;\r\n                    let y = this.top + newTileSize[1]*i + newTileSize[1]/2;\r\n\r\n                    // this.ctrlsCtx.fillStyle = this.getPixelColor(x,y);\r\n                    this.ctrlsCtx.fillStyle = \"rgba(255,255,255,0.5)\";\r\n                    // this.ctrlsCtx.strokeStyle = \"black\";\r\n                    this.ctrlsCtx.beginPath();\r\n                    this.ctrlsCtx.arc(x, y, 1, 0, 2 * Math.PI);\r\n                    // this.ctrlsCtx.stroke();\r\n                    this.ctrlsCtx.fill();\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    getPixelColor(x,y){\r\n        if(!x || !y) return \"rgba(0,0,0,0)\";\r\n        let pixelData = this.imgCtx.getImageData(x,y,1,1).data;\r\n        let rgba = `rgba(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]}, ${pixelData[3] / 255})`;\r\n\r\n        return rgba;\r\n    }\r\n\r\n    openModal () {\r\n        this.active = true;\r\n        document.getElementById(\"modalOverlay\").style.display = \"block\";\r\n    }\r\n\r\n    closeModal () {\r\n        this.active = false;\r\n        document.getElementById(\"modalOverlay\").style.display = \"none\";\r\n    }\r\n\r\n    // isSlider(x,y) {\r\n    //     if()\r\n\r\n    // }\r\n\r\n}\r\n\r\nclass App {\r\n    start = true;\r\n    startTime;\r\n    takingInput = true;\r\n\r\n    curDir;\r\n    dasFired = false;\r\n    softDrop = false;\r\n    dasCancel;\r\n    arrCancel;\r\n    softCancel;\r\n\r\n    constructor() {\r\n\r\n        this.input = new InputManager((key, state) => this.handleInput(key, state));\r\n        this.board = new GameBoard(20, 10, 30);\r\n        this.settings = new Settings(this.input, () => this.pauseInput(), () => this.resumeInput(), this.board);\r\n        this.paster = new Paster();\r\n\r\n        this.lastTick = performance.now();\r\n        this.lastRender = this.lastTick;\r\n        // this.tickLength = 50;\r\n        this.tickLength = 25;\r\n\r\n        // load board if parameter given\r\n        let url = window.location.href;\r\n        let params = new URLSearchParams(url.split('?')[1]);\r\n\r\n        if(params.has('data')){\r\n            this.board.loadData(params.get('data'));\r\n        }\r\n    }\r\n\r\n\r\n\r\n    update() {\r\n        // game logic\r\n        if(this.start){\r\n            if(this.paster.active){\r\n                this.board.isPaused = true;\r\n            }\r\n            else{\r\n                this.board.isPaused = false;\r\n                this.board.update();\r\n            }\r\n            // this.board.activePiece = this.board.queue.getCurrent();\r\n            if(this.dasFired && this.settings.arr === 0){\r\n                this.board.shiftInstant(this.curDir);\r\n            }\r\n            // if(this.paster.active){\r\n            //     this.paster.update();\r\n            // }\r\n        }\r\n    }\r\n\r\n    initiateDas(key,dir) {\r\n        this.cancelDas();\r\n        this.curDir = dir;\r\n\r\n        this.board.shiftPiece(dir);\r\n        this.dasCancel = setTimeout( () => {\r\n            this.dasFired = true;\r\n            if(this.input.keysDown[key]) {\r\n                if(this.settings.arr === 0) this.board.shiftInstant(dir, this.settings.softDrop === 0 && this.softDrop);\r\n                else{\r\n                    this.arrCancel = setInterval(() => {\r\n                        if(this.input.keysDown[key]) this.board.shiftPiece(dir) \r\n                        else this.cancelDas();\r\n                    }, this.settings.arr);\r\n                }\r\n            }\r\n            else this.cancelDas();\r\n        }, this.settings.das);\r\n    }\r\n\r\n    cancelDas() {\r\n        if(this.dasCancel) clearTimeout(this.dasCancel);\r\n        if(this.arrCancel) clearInterval(this.arrCancel);\r\n        this.dasFired = false;\r\n        this.dasCancel = null;\r\n        this.arrCancel = null;\r\n        this.curDir = null;\r\n    }\r\n\r\n    handleInput(key, state) {\r\n        if(this.takingInput){\r\n            //special keys\r\n            // if(key === \"Control\"){\r\n            //     if(state) this.board.sketcher.ctrlKey = true;\r\n            //     else this.board.sketcher.ctrlKey = false;\r\n            // }\r\n            // if(key === \"Shift\"){\r\n            //     if(state) this.board.sketcher.shiftKey = true;\r\n            //     else this.board.sketcher.shiftKey = false;\r\n            // }\r\n            // if(key === \"Alt\"){\r\n            //     if(state) this.board.sketcher.altKey = true;\r\n            //     else this.board.sketcher.altKey = false;\r\n            // }\r\n            if(key === \"Escape\"){\r\n                this.board.sketcher.unselectAll();\r\n                this.paster.closeModal();\r\n            }\r\n            if(key === \"Enter\"){\r\n                if(this.paster.active){\r\n                    this.board.playfield.board = this.paster.preview.copy().board;\r\n                    this.paster.closeModal();\r\n                }\r\n            }\r\n\r\n            // game controls\r\n            if(key === this.settings.keybinds.leftKey){\r\n                if(state) this.initiateDas(key,\"left\");\r\n                else if(this.curDir === \"left\") this.cancelDas();\r\n            }\r\n            else if(key === this.settings.keybinds.rightKey){\r\n                if(state) this.initiateDas(key,\"right\");\r\n                else if(this.curDir === \"right\") this.cancelDas();\r\n            }\r\n            else if(key === this.settings.keybinds.softKey){\r\n                if(state){\r\n                    this.softDrop = true;\r\n                    if(this.settings.softDrop === 0) this.board.shiftInstant(\"down\");\r\n                    this.softCancel = setInterval(() => {\r\n                        if(this.input.keysDown[key]) this.board.shiftPiece(\"down\");\r\n                        else clearInterval(this.softCancel); \r\n                    }, this.settings.softDrop);\r\n                }\r\n                else if(this.softDrop) {\r\n                    this.softDrop = false;\r\n                    clearInterval(this.softCancel);\r\n                }\r\n            }\r\n            else if(state && key === this.settings.keybinds.hardKey){\r\n                this.board.hardDrop();\r\n                // this.queue.queueStep();\r\n            }\r\n            else if(state && key === this.settings.keybinds.holdKey){\r\n                this.board.holdPiece();\r\n            }\r\n            else if(state && key === this.settings.keybinds.crKey){\r\n                this.board.rotateActive(1);\r\n            }\r\n            else if(state && key === this.settings.keybinds.ccrKey){\r\n                this.board.rotateActive(-1);\r\n            }\r\n            else if(state && key === this.settings.keybinds.r180Key){\r\n                this.board.rotateActive(2);\r\n            }\r\n            else if(state && key === this.settings.keybinds.restartKey){\r\n                this.startGame();\r\n            }\r\n            else if(state && key === this.settings.keybinds.undoKey){\r\n                this.board.setState(-1);\r\n            }\r\n            else if(state && key === this.settings.keybinds.redoKey){\r\n                this.board.setState(1);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    render() {\r\n        this.board.renderBoard();\r\n        this.paster.render();\r\n    }\r\n\r\n    startGame() {\r\n        this.startTime = performance.now();\r\n        this.board.resetBoard();\r\n        this.start = true;\r\n    }\r\n\r\n    pauseInput(){\r\n        this.takingInput = false;\r\n        this.board.isPaused = true;\r\n    }\r\n\r\n    resumeInput(){\r\n        this.takingInput = true;\r\n        this.board.isPaused = false;\r\n    }\r\n\r\n}\r\n\r\n\r\nlet app = new App();\r\n(() => {\r\n    function main(tFrame){\r\n        app.stopId = window.requestAnimationFrame(main);\r\n\r\n        const nextTick = app.lastTick + app.tickLength;\r\n        let numTicks = 0;\r\n\r\n        if(tFrame > nextTick){\r\n            const timeSinceTick = tFrame - app.lastTick;\r\n            numTicks = Math.floor(timeSinceTick / app.tickLength);\r\n\r\n        }\r\n\r\n        for (let i = 0; i < numTicks; i++) {\r\n            app.lastTick += app.tickLength;\r\n            app.update(app.lastTick);\r\n        }\r\n\r\n        app.render();\r\n    }\r\n\r\n    main(performance.now());\r\n})()\r\n\r\n\r\n\n\n//# sourceURL=webpack://sketris/./src/sketris.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   colorComp: () => (/* binding */ colorComp),\n/* harmony export */   colorDelta: () => (/* binding */ colorDelta),\n/* harmony export */   dataToString: () => (/* binding */ dataToString),\n/* harmony export */   deltaE: () => (/* binding */ deltaE),\n/* harmony export */   parseColor: () => (/* binding */ parseColor),\n/* harmony export */   stringToData: () => (/* binding */ stringToData)\n/* harmony export */ });\nlet clamp = (x,lower,higher) => Math.max(Math.min(x, higher), lower);\r\n\r\nlet parseColor = (str) => {\r\n    if ('#' == str[0] && 7 == str.length) {\r\n        return {\r\n            r: parseInt(str.slice(1, 3), 16),\r\n            g: parseInt(str.slice(3, 5), 16),\r\n            b: parseInt(str.slice(5, 7), 16),\r\n            a: 1\r\n        }\r\n    }\r\n    if (0 == str.indexOf('rgba(')) {\r\n        str = str.match(/rgba\\(([^)]+)\\)/)[1];\r\n        var parts = str.split(/ *, */).map(Number);\r\n        return {\r\n            r: parts[0],\r\n            g: parts[1],\r\n            b: parts[2],\r\n            a: parts[3]\r\n        }\r\n    }\r\n    if (0 == str.indexOf('rgb(')) {\r\n        str = str.match(/rgb\\(([^)]+)\\)/)[1];\r\n        var parts = str.split(/ *, */).map(Number);\r\n        return {\r\n            r: parts[0],\r\n            g: parts[1],\r\n            b: parts[2],\r\n            a: 1\r\n        }\r\n    }\r\n}\r\n\r\nfunction colorComp(a,b){\r\n    if(!a || !b) return false;\r\n    const rgbToHex = (s) => {\r\n        if(s[0] != 'r') return false;\r\n        let [r,g,b] = s.split(\"(\")[1].split(\")\")[0].split(\",\").map( (x) => parseInt(x));\r\n        return '#' + [r, g, b].map(x => {\r\n            const hex = x.toString(16)\r\n            return hex.length === 1 ? '0' + hex : hex\r\n        }).join('')\r\n    }\r\n    return a == b || rgbToHex(a) == b || rgbToHex(b) == a;\r\n}\r\n\r\n// simple color delta\r\nfunction colorDelta(rgbA, rgbB){\r\n    return Math.pow(Math.abs(rgbA.r - rgbB.r),2) +\r\n    Math.pow(Math.abs(rgbA.g - rgbB.g),2) +\r\n    Math.pow(Math.abs(rgbA.b - rgbB.b),2);\r\n\r\n}\r\n\r\n// color similarity comparison https://github.com/antimatter15/rgb-lab\r\nfunction deltaE(rgbA, rgbB) {\r\n  let labA = rgb2lab(rgbA);\r\n  let labB = rgb2lab(rgbB);\r\n  let deltaL = labA[0] - labB[0];\r\n  let deltaA = labA[1] - labB[1];\r\n  let deltaB = labA[2] - labB[2];\r\n  let c1 = Math.sqrt(labA[1] * labA[1] + labA[2] * labA[2]);\r\n  let c2 = Math.sqrt(labB[1] * labB[1] + labB[2] * labB[2]);\r\n  let deltaC = c1 - c2;\r\n  let deltaH = deltaA * deltaA + deltaB * deltaB - deltaC * deltaC;\r\n  deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);\r\n  let sc = 1.0 + 0.045 * c1;\r\n  let sh = 1.0 + 0.015 * c1;\r\n  let deltaLKlsl = deltaL / (1.0);\r\n  let deltaCkcsc = deltaC / (sc);\r\n  let deltaHkhsh = deltaH / (sh);\r\n  let i = deltaLKlsl * deltaLKlsl + deltaCkcsc * deltaCkcsc + deltaHkhsh * deltaHkhsh;\r\n  return i < 0 ? 0 : Math.sqrt(i);\r\n}\r\n\r\nfunction rgb2lab(rgb){\r\n  let r = rgb.r / 255, g = rgb.g / 255, b = rgb.b / 255, x, y, z;\r\n  r = (r > 0.04045) ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\r\n  g = (g > 0.04045) ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\r\n  b = (b > 0.04045) ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;\r\n  x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;\r\n  y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.00000;\r\n  z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;\r\n  x = (x > 0.008856) ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;\r\n  y = (y > 0.008856) ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;\r\n  z = (z > 0.008856) ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;\r\n  return [(116 * y) - 16, 500 * (x - y), 200 * (y - z)]\r\n}\r\n\r\nfunction dataToString(buffer){\r\n    let byteBoard = new Uint8Array(buffer);\r\n    let s = \"\";\r\n    for(let i=0; i < byteBoard.length; i++){\r\n        let data = byteBoard[i];\r\n        // console.log(byteBoard[i].toString(2).padStart(8,'0'))\r\n        s += String.fromCharCode(data);\r\n    }\r\n\r\n    return window.btoa(s);\r\n}\r\n\r\nfunction stringToData(s){\r\n    //decode string\r\n    let decoded = window.atob(s);\r\n\r\n    //build board\r\n    let b = new Uint8Array(decoded.length);\r\n    for(let i=0; i<decoded.length; i++){\r\n        b[i] = decoded.charCodeAt(i);\r\n    }\r\n\r\n    return b.buffer;\r\n\r\n}\n\n//# sourceURL=webpack://sketris/./src/utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	__webpack_require__("./src/sketris.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/utils.js");
/******/ 	
/******/ })()
;
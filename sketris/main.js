/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/lz-string/libs/lz-string.js":
/*!**************************************************!*\
  !*** ./node_modules/lz-string/libs/lz-string.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>\n// This work is free. You can redistribute it and/or modify it\n// under the terms of the WTFPL, Version 2\n// For more information see LICENSE.txt or http://www.wtfpl.net/\n//\n// For more information, the home page:\n// http://pieroxy.net/blog/pages/lz-string/testing.html\n//\n// LZ-based compression algorithm, version 1.4.5\nvar LZString = (function() {\n\n// private property\nvar f = String.fromCharCode;\nvar keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nvar keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\nvar baseReverseDic = {};\n\nfunction getBaseValue(alphabet, character) {\n  if (!baseReverseDic[alphabet]) {\n    baseReverseDic[alphabet] = {};\n    for (var i=0 ; i<alphabet.length ; i++) {\n      baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n    }\n  }\n  return baseReverseDic[alphabet][character];\n}\n\nvar LZString = {\n  compressToBase64 : function (input) {\n    if (input == null) return \"\";\n    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});\n    switch (res.length % 4) { // To produce valid Base64\n    default: // When could this happen ?\n    case 0 : return res;\n    case 1 : return res+\"===\";\n    case 2 : return res+\"==\";\n    case 3 : return res+\"=\";\n    }\n  },\n\n  decompressFromBase64 : function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });\n  },\n\n  compressToUTF16 : function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 15, function(a){return f(a+32);}) + \" \";\n  },\n\n  decompressFromUTF16: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });\n  },\n\n  //compress into uint8array (UCS-2 big endian format)\n  compressToUint8Array: function (uncompressed) {\n    var compressed = LZString.compress(uncompressed);\n    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character\n\n    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {\n      var current_value = compressed.charCodeAt(i);\n      buf[i*2] = current_value >>> 8;\n      buf[i*2+1] = current_value % 256;\n    }\n    return buf;\n  },\n\n  //decompress from uint8array (UCS-2 big endian format)\n  decompressFromUint8Array:function (compressed) {\n    if (compressed===null || compressed===undefined){\n        return LZString.decompress(compressed);\n    } else {\n        var buf=new Array(compressed.length/2); // 2 bytes per character\n        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {\n          buf[i]=compressed[i*2]*256+compressed[i*2+1];\n        }\n\n        var result = [];\n        buf.forEach(function (c) {\n          result.push(f(c));\n        });\n        return LZString.decompress(result.join(''));\n\n    }\n\n  },\n\n\n  //compress into a string that is already URI encoded\n  compressToEncodedURIComponent: function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});\n  },\n\n  //decompress from an output of compressToEncodedURIComponent\n  decompressFromEncodedURIComponent:function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    input = input.replace(/ /g, \"+\");\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });\n  },\n\n  compress: function (uncompressed) {\n    return LZString._compress(uncompressed, 16, function(a){return f(a);});\n  },\n  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {\n    if (uncompressed == null) return \"\";\n    var i, value,\n        context_dictionary= {},\n        context_dictionaryToCreate= {},\n        context_c=\"\",\n        context_wc=\"\",\n        context_w=\"\",\n        context_enlargeIn= 2, // Compensate for the first entry which should not count\n        context_dictSize= 3,\n        context_numBits= 2,\n        context_data=[],\n        context_data_val=0,\n        context_data_position=0,\n        ii;\n\n    for (ii = 0; ii < uncompressed.length; ii += 1) {\n      context_c = uncompressed.charAt(ii);\n      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {\n        context_dictionary[context_c] = context_dictSize++;\n        context_dictionaryToCreate[context_c] = true;\n      }\n\n      context_wc = context_w + context_c;\n      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {\n        context_w = context_wc;\n      } else {\n        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n          if (context_w.charCodeAt(0)<256) {\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<8 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          } else {\n            value = 1;\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1) | value;\n              if (context_data_position ==bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = 0;\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<16 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          }\n          context_enlargeIn--;\n          if (context_enlargeIn == 0) {\n            context_enlargeIn = Math.pow(2, context_numBits);\n            context_numBits++;\n          }\n          delete context_dictionaryToCreate[context_w];\n        } else {\n          value = context_dictionary[context_w];\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n\n\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        // Add wc to the dictionary.\n        context_dictionary[context_wc] = context_dictSize++;\n        context_w = String(context_c);\n      }\n    }\n\n    // Output the code for w.\n    if (context_w !== \"\") {\n      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n        if (context_w.charCodeAt(0)<256) {\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<8 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        } else {\n          value = 1;\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | value;\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = 0;\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<16 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        delete context_dictionaryToCreate[context_w];\n      } else {\n        value = context_dictionary[context_w];\n        for (i=0 ; i<context_numBits ; i++) {\n          context_data_val = (context_data_val << 1) | (value&1);\n          if (context_data_position == bitsPerChar-1) {\n            context_data_position = 0;\n            context_data.push(getCharFromInt(context_data_val));\n            context_data_val = 0;\n          } else {\n            context_data_position++;\n          }\n          value = value >> 1;\n        }\n\n\n      }\n      context_enlargeIn--;\n      if (context_enlargeIn == 0) {\n        context_enlargeIn = Math.pow(2, context_numBits);\n        context_numBits++;\n      }\n    }\n\n    // Mark the end of the stream\n    value = 2;\n    for (i=0 ; i<context_numBits ; i++) {\n      context_data_val = (context_data_val << 1) | (value&1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data_position = 0;\n        context_data.push(getCharFromInt(context_data_val));\n        context_data_val = 0;\n      } else {\n        context_data_position++;\n      }\n      value = value >> 1;\n    }\n\n    // Flush the last char\n    while (true) {\n      context_data_val = (context_data_val << 1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data.push(getCharFromInt(context_data_val));\n        break;\n      }\n      else context_data_position++;\n    }\n    return context_data.join('');\n  },\n\n  decompress: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });\n  },\n\n  _decompress: function (length, resetValue, getNextValue) {\n    var dictionary = [],\n        next,\n        enlargeIn = 4,\n        dictSize = 4,\n        numBits = 3,\n        entry = \"\",\n        result = [],\n        i,\n        w,\n        bits, resb, maxpower, power,\n        c,\n        data = {val:getNextValue(0), position:resetValue, index:1};\n\n    for (i = 0; i < 3; i += 1) {\n      dictionary[i] = i;\n    }\n\n    bits = 0;\n    maxpower = Math.pow(2,2);\n    power=1;\n    while (power!=maxpower) {\n      resb = data.val & data.position;\n      data.position >>= 1;\n      if (data.position == 0) {\n        data.position = resetValue;\n        data.val = getNextValue(data.index++);\n      }\n      bits |= (resb>0 ? 1 : 0) * power;\n      power <<= 1;\n    }\n\n    switch (next = bits) {\n      case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 2:\n        return \"\";\n    }\n    dictionary[3] = c;\n    w = c;\n    result.push(c);\n    while (true) {\n      if (data.index > length) {\n        return \"\";\n      }\n\n      bits = 0;\n      maxpower = Math.pow(2,numBits);\n      power=1;\n      while (power!=maxpower) {\n        resb = data.val & data.position;\n        data.position >>= 1;\n        if (data.position == 0) {\n          data.position = resetValue;\n          data.val = getNextValue(data.index++);\n        }\n        bits |= (resb>0 ? 1 : 0) * power;\n        power <<= 1;\n      }\n\n      switch (c = bits) {\n        case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 2:\n          return result.join('');\n      }\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n      if (dictionary[c]) {\n        entry = dictionary[c];\n      } else {\n        if (c === dictSize) {\n          entry = w + w.charAt(0);\n        } else {\n          return null;\n        }\n      }\n      result.push(entry);\n\n      // Add w+entry[0] to the dictionary.\n      dictionary[dictSize++] = w + entry.charAt(0);\n      enlargeIn--;\n\n      w = entry;\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n    }\n  }\n};\n  return LZString;\n})();\n\nif (true) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return LZString; }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n\n\n//# sourceURL=webpack://sketris/./node_modules/lz-string/libs/lz-string.js?");

/***/ }),

/***/ "./src/sketris.js":
/*!************************!*\
  !*** ./src/sketris.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lz_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lz-string */ \"./node_modules/lz-string/libs/lz-string.js\");\n/* harmony import */ var lz_string__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lz_string__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n\r\n\r\n\r\nclass GameBoard {\r\n\r\n    constructor(rows, cols, tileSize=30, spawnArea=2) {\r\n\r\n        this.rows = rows;\r\n        this.cols = cols;\r\n        this.tileSize = tileSize;\r\n        this.spawnArea = spawnArea;\r\n\r\n        this.boardHeight = (rows+this.spawnArea)*tileSize;   \r\n        this.boardWidth = cols*tileSize;   \r\n\r\n        this.playfield = new Playfield(this.rows, this.cols, this.tileSize, this.spawnArea);\r\n        this.hold = new Hold(this.tileSize);\r\n        this.queue = new Queue(this.tileSize);\r\n\r\n        this.sketcher = new Sketcher(this.playfield, () => this.getActivePiece(), () => this.saveState());\r\n        this.history = new BoardHistory();\r\n\r\n        this.activePiece =  null;\r\n        this.isPaused = false;\r\n    }\r\n    \r\n    update(){\r\n        this.queue.updateQueue();\r\n        if(!this.activePiece || this.activePiece.name !== this.queue.getCurrent()){\r\n            // this.activePiece = new Piece(this.queue.getCurrent());\r\n            this.spawnPiece();\r\n        }\r\n\r\n    }\r\n\r\n    lstGuide() {\r\n        // mirror 0,1 3,4 to tallest\r\n\r\n        let getCol = (i) => {return this.playfield.board.map((r) => r[i])}\r\n        let topActiveIndex = (c) => {\r\n            for(let i=0; i<c.length; i++){\r\n                if(c[i].active){\r\n                    return c[i].y\r\n                }\r\n            }\r\n            return this.rows + this.spawnArea;\r\n        }\r\n        let topSelectIndex = (c) => {\r\n            for(let i=0; i<c.length; i++){\r\n                if(c[i].selected){\r\n                    return c[i].y\r\n                }\r\n            }\r\n            return this.rows + this.spawnArea;\r\n        }\r\n        \r\n        let cols = [];\r\n        for(let i=0; i<this.cols; i++){\r\n            cols.push(getCol(i));\r\n        }\r\n\r\n        // console.log(cols[0][0]);\r\n        // return\r\n\r\n        let mirror = (a,b) =>{\r\n            let topA = topActiveIndex(cols[a]);\r\n            let topB = topActiveIndex(cols[b]);\r\n\r\n            let lowCol = topA >= topB ? cols[a] : cols[b];\r\n            let highCol = topA >= topB ? cols[b] : cols[a];\r\n            let topInd = topActiveIndex(highCol);\r\n\r\n            if(topA == topB){\r\n                for(let i=(this.rows + this.spawnArea)-1; i >= 0; i--){\r\n                    lowCol[i].selected = false;\r\n                    highCol[i].selected = false;\r\n\r\n                };\r\n                return;\r\n            }\r\n\r\n            for(let i=(this.rows + this.spawnArea)-1; i >= 0; i--){\r\n                let t = lowCol[i];\r\n                if((i >= topInd && !t.active && highCol[i].active) || highCol[i].selected){\r\n                    t.selected = true;\r\n                }else t.selected = false;\r\n\r\n                if(i >= topInd){\r\n                    highCol[i].selected = false;\r\n                }\r\n\r\n                if(i < topInd && (lowCol[i].selected || highCol[i].selected)){\r\n                    lowCol[i].selected = true;\r\n                    highCol[i].selected = true;\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n        \r\n        mirror(0,4);\r\n        mirror(1,3);\r\n\r\n        //lst logic\r\n\r\n        // return\r\n\r\n        // check tops, 2 cases\r\n\r\n        // select appropriate\r\n\r\n    }\r\n\r\n    countToFourGuide() {\r\n        let getCol = (i) => {return this.playfield.board.map((r) => r[i])}\r\n        let topActiveIndex = (c) => {\r\n            for(let i=0; i<c.length; i++){\r\n                if(c[i].active){\r\n                    return c[i].y\r\n                }\r\n            }\r\n            return this.rows + this.spawnArea;\r\n        }\r\n\r\n        // find first garbage row covering well\r\n        let lowColTop = 0;\r\n        for (let i = 0; i < this.playfield.cols; i++) {\r\n            lowColTop = Math.max(topActiveIndex(getCol(i)), lowColTop);\r\n        }\r\n\r\n        // console.log(lowColTop);\r\n\r\n        // draw 4x10 box starting at row\r\n        this.playfield.ctx.fillStyle = \"rgba(200,200,200, 0.08)\";\r\n        this.playfield.ctx.fillRect(0, this.tileSize*(lowColTop-4), this.playfield.canvas.width, this.tileSize*4);\r\n\r\n        this.playfield.ctx.strokeStyle = \"rgba(200,0,200, 0.5)\";\r\n        this.playfield.ctx.moveTo(0, this.tileSize*lowColTop)\r\n        this.playfield.ctx.lineTo(this.playfield.canvas.width, this.tileSize*lowColTop);\r\n        this.playfield.ctx.stroke();\r\n        // this.playfield.ctx.fillRect(50,50,50,50);\r\n        // this.playfield.ctx.stroke();\r\n\r\n        // highlight avoid box\r\n\r\n    }\r\n\r\n    getActivePiece() {\r\n        return this.activePiece;\r\n    }\r\n\r\n    renderBoard(){\r\n        this.playfield.render(this.isPaused);\r\n        this.queue.renderQueue();\r\n        this.hold.renderHold();\r\n        this.renderActive();\r\n\r\n        // temp testing\r\n        // this.countToFourGuide();\r\n    }\r\n\r\n    renderActive(){\r\n        if(this.activePiece){\r\n            // TODO colored ghost\r\n            // draw ghost first\r\n            let ghost = this.activePiece.copy();\r\n            let origColor = _utils_js__WEBPACK_IMPORTED_MODULE_1__.parseColor(ghost.color)\r\n            ghost.color = \"rgba(\" + origColor.r + \",\" + origColor.g + \",\" + origColor.b + \",\" + 0.5 + \")\"; \r\n\r\n            this.shiftInstant(\"down\",false, ghost);\r\n            \r\n            for (let i = 0; i < ghost.tiles.length; i++) {\r\n                this.playfield.colorTile(ghost.tiles[i]);\r\n            }\r\n\r\n            // activePiece\r\n            for (let i = 0; i < this.activePiece.tiles.length; i++) {\r\n                this.playfield.colorTile(this.activePiece.tiles[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    // loadPlayfield(p) {\r\n    //     this.playfield = p;\r\n    //     this.sketcher = new Sketcher(thiskplayfield);\r\n    // }\r\n\r\n    saveState(){\r\n        this.history.addState(this.playfield.copy(), this.queue.copy(), this.hold.copy());\r\n        // console.log(this.history.getState());\r\n        // BoardHistory.stateToString(this.history.getState());\r\n        // let a=JSON.stringify(this.history)\r\n        // let b=LZString.compress(a);\r\n\r\n        // console.log(' ');\r\n        // console.log(a);\r\n        // console.log(new Blob([a]).size);\r\n        // console.log(' ');\r\n        // console.log(b);\r\n        // console.log(new Blob([b]).size);\r\n        // console.log(' ');\r\n\r\n    }\r\n\r\n    setState(n){\r\n        let state = this.history.getState(n);\r\n        if(state){\r\n            this.playfield.setField(state);\r\n            this.queue = state.queue.copy();\r\n            this.hold = state.hold.copy();\r\n            this.spawnPiece(false);\r\n            // this.activePiece = new Piece(this.queue.getCurrent());\r\n            this.renderBoard();\r\n        }\r\n    }\r\n\r\n    spawnPiece(newState=true, das=null) {\r\n        let spawnX = Math.ceil(this.cols / 2) - 2;\r\n        this.activePiece = new Piece(this.queue.getCurrent(), spawnX, 0);\r\n        if(this.collisionCheck(this.activePiece, this.playfield)){\r\n            this.activePiece = null;\r\n            return false;\r\n        };\r\n\r\n        if(newState){\r\n            this.saveState();\r\n            // this.history.addState(this.playfield.copy(), this.queue.copy(), this.hold.copy());\r\n        }\r\n\r\n        if(das === 'r') this.shiftInstant('right');\r\n        else if(das === 'l') this.shiftInstant('left');\r\n\r\n        return true;\r\n    }\r\n\r\n    holdPiece(){\r\n        if(this.activePiece){\r\n            if(this.hold.pieceName){\r\n                let holdName = this.hold.getHold();\r\n                this.hold.setHold(this.activePiece.name); \r\n                this.queue.setCurrent(holdName);\r\n                // console.log(holdName);\r\n            }\r\n            else{\r\n                this.hold.setHold(this.activePiece.name);\r\n                this.queue.queueStep();\r\n                this.spawnPiece();\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    collisionCheck(piece, playfield) {\r\n        for (let i = 0; i < piece.tiles.length; i++) {\r\n            let tile = piece.tiles[i];\r\n            if(tile.y < 0 || tile.x < 0  \r\n                || tile.y > (this.rows+this.spawnArea) - 1\r\n                || tile.x > this.cols - 1              \r\n                || playfield.board[tile.y][tile.x].active){\r\n                    return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    shiftPiece(dir, p=this.activePiece){\r\n        if(p){\r\n            // try update\r\n            if(dir === \"left\") p.move(0,-1);\r\n            else if(dir === \"right\") p.move(0,1);\r\n            else if(dir === \"down\") p.move(1,0);\r\n\r\n            if(!this.collisionCheck(p, this.playfield)){\r\n                return true;\r\n            }\r\n\r\n            //revert\r\n            if(dir === \"left\") p.move(0,1);\r\n            else if(dir === \"right\") p.move(0,-1);\r\n            else if(dir === \"down\") p.move(-1,0);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    shiftInstant(dir, drop=false, p=this.activePiece){\r\n        if(p){\r\n            if(dir === \"left\") while(this.shiftPiece(\"left\", p)){\r\n                if(drop) this.shiftInstant(\"down\", drop, p);\r\n            }\r\n            else if(dir === \"right\") while(this.shiftPiece(\"right\", p)){\r\n                if(drop) this.shiftInstant(\"down\", drop, p);\r\n            }\r\n            else if(dir === \"down\") while(this.shiftPiece(\"down\", p)){}\r\n        }\r\n    }\r\n\r\n    rotateActive(x){\r\n        if(this.activePiece){\r\n            let oldRot = this.activePiece.rot;\r\n            let mod = (n, m) => ((n % m) + m) % m;\r\n            let newRot = mod(this.activePiece.rot + x, 4);\r\n            this.activePiece.rotate(newRot);\r\n\r\n            let kicks;\r\n            if(this.activePiece.name === \"i\") kicks = this.kickTable.i[oldRot][newRot];\r\n            else kicks = this.kickTable.n[oldRot][newRot]; \r\n\r\n            // TODO null check\r\n            if(kicks){\r\n                // try all kicks;\r\n                for (let i = 0; i < kicks.length; i++) {\r\n                    let kick = kicks[i];\r\n                    this.activePiece.move(-kick[1], kick[0]);\r\n\r\n                    if(!this.collisionCheck(this.activePiece, this.playfield)){\r\n                        return true;\r\n                    }\r\n\r\n                    // revert\r\n                    this.activePiece.move(kick[1], -kick[0]);\r\n                }\r\n            };\r\n\r\n            // revert\r\n            this.activePiece.rotate(oldRot);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    hardDrop(p=this.activePiece) {\r\n        if(p){\r\n            while(this.shiftPiece(\"down\", p)){}\r\n\r\n            this.playfield.write(this.activePiece)\r\n            this.playfield.clearLines();\r\n            this.queue.queueStep();\r\n            this.spawnPiece();\r\n        }\r\n    }\r\n\r\n    resetBoard() {\r\n        this.playfield.reset();\r\n        this.hold.setHold(\"\");\r\n        this.queue.reset();\r\n        this.history.reset();\r\n        this.spawnPiece();\r\n        // this.activePiece = new Piece(this.queue.getCurrent());\r\n    }\r\n\r\n    kickTable = {\r\n        // srs+ -- uses tetrio 180 kicks\r\n        n :{\r\n            0 : {\r\n                0 : [[0,0]],\r\n                1 : [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],\r\n                2 : [[0,0],[0,1],[1,1],[-1,1],[1,0],[-1,0]],\r\n                3 : [[0,0],[1,0],[1,1],[0,-2],[1,-2]],\r\n            },\r\n            1 : {\r\n                0 : [[0,0],[1,0],[1,-1],[0,2],[1,2]],\r\n                1 : [[0,0]],\r\n                2 : [[0,0],[1,0],[1,-1],[0,2],[1,2]],\r\n                3 : [[0,0],[1,0],[1,2],[1,1],[0,2],[0,1]],\r\n            },\r\n            2 : {\r\n                0 : [[0,0],[0,-1],[-1,-1],[1,-1],[-1,0],[1,0]],\r\n                1 : [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],\r\n                2 : [[0,0]],\r\n                3 : [[0,0],[1,0],[1,1],[0,-2],[1,-2]],\r\n            },\r\n            3 : {\r\n                0 : [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],\r\n                1 : [[0,0],[-1,0],[-1,2],[-1,1],[0,2],[0,1]],\r\n                2 : [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],\r\n                3 : [[0,0]],\r\n            },\r\n        },\r\n        // TODO: use better i kicks? check the wiki\r\n        i : {\r\n            0 : {\r\n                0 : [[0,0]],\r\n                1 : [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],\r\n                2 : [[0,0]],\r\n                3 : [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],\r\n            },\r\n            1 : {\r\n                0 : [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],\r\n                1 : [[0,0]],\r\n                2 : [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],\r\n                3 : [[0,0]],\r\n            },\r\n            2 : {\r\n                0 : [[0,0]],\r\n                1 : [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],\r\n                2 : [[0,0]],\r\n                3 : [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],\r\n            },\r\n            3 : {\r\n                0 : [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],\r\n                1 : [[0,0]],\r\n                2 : [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],\r\n                3 : [[0,0]],\r\n            },\r\n\r\n        }\r\n    }\r\n\r\n}\r\n\r\nclass Playfield {\r\n    constructor(rows, cols, tileSize, spawnArea){\r\n        this.rows = rows;\r\n        this.cols = cols;\r\n        this.tileSize = tileSize;\r\n        this.spawnArea = spawnArea;\r\n\r\n        this.boardHeight = (rows+this.spawnArea)*tileSize;   \r\n        this.boardWidth = cols*tileSize;   \r\n\r\n        // initialize board\r\n        this.board = [];\r\n        for (let i = 0; i < this.rows+this.spawnArea; i++) {\r\n            let row = [];\r\n            for (let j = 0; j < this.cols; j++) {\r\n                row.push(new Tile(j,i));\r\n            }\r\n            this.board.push(row);\r\n        }\r\n\r\n        this.canvas = document.getElementById(\"field\");\r\n        this.ctx = this.canvas.getContext(\"2d\");\r\n\r\n        this.backgroundCanvas = document.getElementById(\"background\");\r\n        this.backgroundCtx = this.backgroundCanvas.getContext(\"2d\");\r\n    }\r\n\r\n    setField(state){\r\n        this.board = state.playfield.copy().board;\r\n    }\r\n\r\n    getAllTiles(){\r\n        let tiles = [];\r\n        for (let i = 0; i < this.rows+this.spawnArea; i++) {\r\n            for (let j = 0; j < this.cols; j++) {\r\n                tiles.push(this.board[i][j]);\r\n            }\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    render(paused=false){\r\n        this.canvas.width = this.boardWidth;\r\n        this.canvas.height = this.boardHeight;\r\n\r\n        this.backgroundCanvas.width = this.boardWidth;\r\n        this.backgroundCanvas.height = this.boardHeight;\r\n\r\n        // clear \r\n        this.backgroundCtx.clearRect(0,0,this.canvas.width,this.canvas.height);\r\n        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\r\n\r\n        //spawn area\r\n        this.backgroundCtx.strokeStyle = \"black\";\r\n        this.backgroundCtx.globalAlpha = 0.6;\r\n        this.backgroundCtx.fillRect(0,0,this.canvas.width,this.spawnArea*this.tileSize);\r\n\r\n        // background + grid\r\n        this.backgroundCtx.globalAlpha = 1;\r\n        this.backgroundCtx.fillRect(0,this.spawnArea*this.tileSize,this.canvas.width,this.canvas.height);\r\n\r\n        // grid lines\r\n        this.backgroundCtx.strokeStyle = \"gray\";\r\n        this.backgroundCtx.globalAlpha = 0.25;\r\n        this.backgroundCtx.setLineDash([this.tileSize*0.25, this.tileSize*0.5, this.tileSize*0.25, 0]);\r\n        for (let i=this.spawnArea; i < this.rows+3; i++){\r\n            this.backgroundCtx.lineWidth = (i === this.spawnArea || i === this.rows+this.spawnArea) ? 1 : 2;\r\n            this.backgroundCtx.beginPath();\r\n            this.backgroundCtx.moveTo(0, i*(this.tileSize) )\r\n            this.backgroundCtx.lineTo(this.boardWidth, i*(this.tileSize));\r\n            this.backgroundCtx.stroke();\r\n        }\r\n        for (let i=0; i < this.cols+1; i++){\r\n            this.backgroundCtx.lineWidth = (i === 0 || i === this.cols) ? 1 : 2;\r\n            this.backgroundCtx.beginPath();\r\n            this.backgroundCtx.moveTo(i*(this.tileSize), this.spawnArea*this.tileSize)\r\n            this.backgroundCtx.lineTo(i*(this.tileSize), this.boardHeight);\r\n            this.backgroundCtx.stroke();\r\n        }\r\n        this.backgroundCtx.globalAlpha = 1;\r\n\r\n        // color board tiles\r\n        for (let row = 0; row < this.board.length; row++) {\r\n            for (let col = 0; col < this.board[row].length; col++) {\r\n                let tile = this.board[row][col]\r\n                if(tile){\r\n                    this.colorTile(tile);\r\n                }\r\n            }\r\n        }\r\n\r\n        // ghosts\r\n\r\n\r\n\r\n        //draw selection outlines\r\n        for (let row = 0; row < this.board.length; row++) {\r\n            for (let col = 0; col < this.board[row].length; col++) {\r\n                let tile = this.board[row][col]\r\n                if(tile){\r\n                    if(tile.selected){\r\n                        this.ctx.fillStyle = \"rgba(200,200,200, 1)\";\r\n                        this.ctx.fillRect((col*this.tileSize) - 2, (row*this.tileSize) - 2, this.tileSize+4, this.tileSize+4);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //clear inner\r\n        for (let row = 0; row < this.board.length; row++) {\r\n            for (let col = 0; col < this.board[row].length; col++) {\r\n                let tile = this.board[row][col]\r\n                if(tile){\r\n                    if(tile.selected){\r\n                        this.ctx.clearRect((col*this.tileSize), (row*this.tileSize), this.tileSize, this.tileSize);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        // redraw tiles\r\n        for (let row = 0; row < this.board.length; row++) {\r\n            for (let col = 0; col < this.board[row].length; col++) {\r\n                let tile = this.board[row][col]\r\n                if(tile && tile.selected){\r\n                    if(!(tile.active||tile.ghost)){\r\n                        this.ctx.clearRect((col*this.tileSize), (row*this.tileSize), this.tileSize, this.tileSize);\r\n                    }\r\n                    else{\r\n                        this.colorTile(tile);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(paused){\r\n            this.ctx.fillStyle = \"black\";\r\n            this.ctx.globalAlpha = 0.4;\r\n            this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);\r\n\r\n\r\n            //pause symbol\r\n            this.ctx.fillStyle = \"gray\";\r\n            this.ctx.globalAlpha = 0.6;\r\n            this.ctx.fillRect(this.canvas.width*0.5 - 30,this.canvas.height*0.5-30, 20, 60);\r\n            this.ctx.fillRect(this.canvas.width*0.5 + 10,this.canvas.height*0.5-30, 20, 60);\r\n        }\r\n\r\n    }\r\n\r\n    write(p){\r\n        // write piece to board\r\n        for (let i = 0; i < p.tiles.length; i++) {\r\n            let tile = p.tiles[i];\r\n            this.board[tile.y][tile.x].active = true;\r\n            this.board[tile.y][tile.x].color = p.color;\r\n        }\r\n    }\r\n\r\n    colorTile(tile, color=tile.color) {\r\n\r\n        // let parseColor = (str) => {\r\n        //     if ('#' == str[0] && 7 == str.length) {\r\n        //         return {\r\n        //             r: parseInt(str.slice(1, 3), 16),\r\n        //             g: parseInt(str.slice(3, 5), 16),\r\n        //             b: parseInt(str.slice(5, 7), 16),\r\n        //             a: 1\r\n        //         }\r\n        //     }\r\n        //     if (0 == str.indexOf('rgba(')) {\r\n        //         str = str.match(/rgba\\(([^)]+)\\)/)[1];\r\n        //         var parts = str.split(/ *, */).map(Number);\r\n        //         return {\r\n        //             r: parts[0],\r\n        //             g: parts[1],\r\n        //             b: parts[2],\r\n        //             a: parts[3]\r\n        //         }\r\n        //     }\r\n        //     if (0 == str.indexOf('rgb(')) {\r\n        //         str = str.match(/rgb\\(([^)]+)\\)/)[1];\r\n        //         var parts = str.split(/ *, */).map(Number);\r\n        //         return {\r\n        //             r: parts[0],\r\n        //             g: parts[1],\r\n        //             b: parts[2],\r\n        //             a: 1\r\n        //         }\r\n        //     }\r\n        // }\r\n\r\n        if(tile.color){\r\n            if(tile.active){\r\n                this.ctx.fillStyle = color;\r\n            }\r\n            else if(tile.ghost){\r\n                // console.log(color);\r\n\r\n                let origColor = _utils_js__WEBPACK_IMPORTED_MODULE_1__.parseColor(color);\r\n                origColor.a = 0.4;\r\n                let ghostColor = \"rgba(\" + origColor.r + \",\" + origColor.g + \",\" + origColor.b + \",\" + origColor.a + \")\";\r\n                // console.log(origColor, ghostColor);\r\n\r\n                this.ctx.fillStyle = ghostColor;\r\n\r\n            }\r\n            else return;\r\n            // console.log(color);\r\n            this.ctx.fillRect(tile.x*this.tileSize, tile.y*this.tileSize, this.tileSize, this.tileSize);\r\n        }\r\n    }\r\n\r\n    isFull(row) {\r\n        for (let i=0; i < row.length; i++) {\r\n            if(!row[i].active) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    clearLines() {\r\n        let newBoard = [];\r\n        let cleared = 0;\r\n        // check lines from bottom up and adjust \r\n        for(let i=this.board.length-1; i>=0; i--){\r\n            let row = this.board[i];\r\n            if(this.isFull(row)){\r\n                cleared += 1;\r\n            }\r\n            else{\r\n                for(let j=0; j<row.length; j++){\r\n                    row[j].y += cleared;\r\n                }\r\n                newBoard.push(row)\r\n            }\r\n        }\r\n\r\n        let newLines = [];\r\n        for(let i=0; i<cleared; i++){\r\n            let row = [];\r\n            for (let j = 0; j < this.cols; j++) {\r\n                row.push(new Tile(j,i));\r\n            }\r\n            newLines.push(row);\r\n        }\r\n\r\n        this.board = [...newLines, ...(newBoard.reverse())];\r\n    }\r\n\r\n    reset() {\r\n        for (let row = 0; row < this.board.length; row++) {\r\n            for (let col = 0; col < this.board[row].length; col++) {\r\n                let tile = this.board[row][col];\r\n                tile.active = false;\r\n                tile.ghost = false;\r\n                tile.selected = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    copy(){\r\n        let copy = new Playfield(this.rows, this.cols, this.tileSize, this.spawnArea);\r\n\r\n        copy.board = [];\r\n        for (let i = 0; i < this.rows+this.spawnArea; i++) {\r\n            let row = [];\r\n            for (let j = 0; j < this.cols; j++) {\r\n                row.push(this.board[i][j].copy());\r\n            }\r\n            copy.board.push(row);\r\n        }\r\n\r\n        return copy;\r\n    }\r\n\r\n}\r\n\r\nclass Sketcher {\r\n    palette = [];\r\n\r\n    mouseRightDown = false;\r\n    mouseLeftDown = false;\r\n    shiftKey = false;\r\n    ctrlKey = false;\r\n    altKey = false;\r\n\r\n    drawColor = \"#888888\";\r\n    drawMode = false;\r\n    drawRectStart;\r\n\r\n    selected = [];\r\n    selectMode = true;\r\n    selectionOffsets = [];\r\n    selectRectStart;\r\n    // unselectFlag;\r\n\r\n    startDragTile;\r\n    dragBounds = {};\r\n    // dragBounds = {lowX: 0, \r\n    //     highX: this.playfield.cols-1, \r\n    //     lowY: 0,\r\n    //     highY: this.playfield.rows-1\r\n    // };\r\n\r\n    mode = null;\r\n\r\n    constructor(playfield, getActivePiece, saveState){\r\n        this.playfield = playfield;\r\n        this.canvas = this.playfield.canvas;\r\n        this.getActivePiece = getActivePiece;\r\n        this.saveState = saveState;\r\n\r\n        // intialize color palette\r\n\r\n        let paletteDiv = document.getElementById(\"palette\");\r\n        let colors = Object.entries(Piece.pieces).map((e) => e[1].color);\r\n        colors.push(\"#888888\");\r\n\r\n        let i = 0\r\n        for (const c of colors) {\r\n            let color = document.createElement(\"div\");\r\n            color.id = \"color-\" + i;\r\n            color.style.background = c;\r\n            color.style.height = \"40px\";\r\n            color.style.width = \"40px\";\r\n            color.style.margin = \"10px\";\r\n            color.style.border = \"5px solid transparent\";\r\n            if(i == 7){\r\n                color.style.borderColor = \"white\";\r\n            }\r\n\r\n            paletteDiv.appendChild(color);\r\n            this.palette.push(color)\r\n\r\n            color.addEventListener('mousedown', (e) => {\r\n                this.drawColor = e.target.style.background;\r\n                this.updatePalette();\r\n            })\r\n            i++;\r\n        }\r\n\r\n\r\n        // add handle mouse logic\r\n        document.addEventListener('mousedown',(e) => {\r\n            if(e.button == 0) this.mouseLeftDown = true; \r\n            if(e.button == 2) this.mouseRightDown = true; \r\n            this.shiftKey = e.shiftKey;\r\n            this.ctrlKey = e.ctrlKey;\r\n            this.altKey = e.altKey;\r\n        });\r\n        document.addEventListener('mouseup',(e) => {\r\n            if(e.button == 0) this.mouseLeftDown = false; \r\n            if(e.button == 2) this.mouseRightDown = false; \r\n            this.shiftKey = e.shiftKey;\r\n            this.ctrlKey = e.ctrlKey;\r\n            this.altKey = e.altKey;\r\n        });\r\n\r\n        this.canvas.addEventListener('mousedown', (e) => {\r\n            if(e.button == 0) this.mouseLeftDown = true; \r\n            if(e.button == 2) this.mouseRightDown = true; \r\n            let tile = this.getTile(e.offsetX, e.offsetY);\r\n            if(!tile) return;\r\n            if(e.button === 1){\r\n                // color picker\r\n                if(tile.active){\r\n                    this.drawColor = tile.color;\r\n                    this.updatePalette();\r\n                }\r\n            }\r\n            else if(this.shiftKey || this.ctrlKey) {\r\n                this.mode = \"select\";\r\n                this.selectMode = !tile.selected;\r\n                if(this.mouseRightDown){\r\n                    this.selectRectStart = [tile.x, tile.y];\r\n                    this.selectRect(this.selectRectStart,[tile.x, tile.y], this.selectMode);\r\n                }\r\n                else this.select(tile, this.selectMode);\r\n            }\r\n            else if(tile.selected){\r\n                // start drag\r\n                // if(tile.selected){\r\n                    this.mode = \"drag\";\r\n                    this.startDragTile = tile;\r\n                    this.selected = this.playfield.getAllTiles().filter((t) => t.selected).map((t) => t.copy());\r\n                    this.selectionOffsets = this.selected.map((t) => {return {x: t.x - this.startDragTile.x, y: t.y - this.startDragTile.y}}, this);\r\n\r\n\r\n                    // compute bounds of drag\r\n                    let lowerX = Math.min(...this.selected.map((t) => t.x));\r\n                    let lowerY = Math.min(...this.selected.map((t) => t.y));\r\n                    let higherX = Math.max(...this.selected.map((t) => t.x));\r\n                    let higherY = Math.max(...this.selected.map((t) => t.y));\r\n\r\n                    this.dragBounds = {lowX: this.startDragTile.x-lowerX, \r\n                        highX: this.startDragTile.x+(this.playfield.cols-1)-higherX, \r\n                        lowY: this.startDragTile.y-lowerY,\r\n                        highY: this.startDragTile.y+(this.playfield.rows+this.playfield.spawnArea-1)-higherY\r\n                    };\r\n\r\n                    this.drag(tile);\r\n                // }\r\n                // else {\r\n                //     this.unselectFlag = true;\r\n                // }\r\n            }\r\n            else{ //draw\r\n                this.mode = \"draw\";\r\n                // this.drawMode = !tile.active || this.drawColor != tile.color;\r\n                this.drawMode = !(tile.active || tile.ghost);\r\n                tile.color = this.drawMode ? this.drawColor : null;\r\n                if(this.mouseRightDown){\r\n                    this.drawRectStart = [tile.x, tile.y];\r\n                    this.drawRect(this.drawRectStart,[tile.x, tile.y]);\r\n                }\r\n                else {\r\n                    this.draw(tile);\r\n                }\r\n            }\r\n        });\r\n        this.canvas.addEventListener('mousemove', (e) => {\r\n            let tile = this.getTile(e.offsetX, e.offsetY);\r\n            if(!tile) return;\r\n            if(this.mode === \"draw\"){\r\n                if(this.mouseRightDown){\r\n                    this.drawRect(this.drawRectStart,[tile.x, tile.y]);\r\n                }\r\n                else if(this.mouseLeftDown){\r\n                    this.draw(tile);\r\n                }\r\n            }\r\n            else if (this.mode === \"select\"){\r\n                if(this.mouseRightDown){\r\n                    this.selectRect(this.selectRectStart,[tile.x, tile.y], this.selectMode);\r\n                }\r\n                else if(this.mouseLeftDown){\r\n                    this.select(tile, this.selectMode);\r\n                }\r\n            }\r\n            else if (this.mode === \"drag\" && this.mouseLeftDown) {\r\n                this.drag(tile);\r\n            }\r\n        });\r\n        this.canvas.addEventListener('mouseup', (e) =>{\r\n            if(e.button == 0) this.mouseLeftDown = false; \r\n            if(e.button == 2) this.mouseRightDown = false; \r\n            let tile = this.getTile(e.offsetX, e.offsetY);\r\n            if(!tile) return;\r\n            if(this.mode === \"drag\"){\r\n                this.mode = \"select\";\r\n            }\r\n\r\n            this.saveState()\r\n        });\r\n\r\n        this.canvas.addEventListener('contextmenu', (e) => {e.preventDefault();e.stopPropagation();return false;}); // disable context menu\r\n        this.canvas.addEventListener('focusout', this.resetInputs); \r\n    }\r\n\r\n    // handleContextMenu(e) {\r\n    //     this.shiftKey = false;\r\n    //     e.preventDefault();\r\n    // }\r\n\r\n    resetInputs(e){\r\n        // console.log(\"reset\", this.altKey);\r\n        this.mouseLeftDown = false;\r\n        this.mouseRightDown = false;\r\n        this.shiftKey = false;\r\n        this.ctrlKey = false;\r\n        this.altKey = false;\r\n    }\r\n\r\n\r\n    static colorComp(a,b){\r\n        if(!a || !b) return false;\r\n        const rgbToHex = (s) => {\r\n            if(s[0] != 'r') return false;\r\n            let [r,g,b] = s.split(\"(\")[1].split(\")\")[0].split(\",\").map( (x) => parseInt(x));\r\n            return '#' + [r, g, b].map(x => {\r\n                const hex = x.toString(16)\r\n                return hex.length === 1 ? '0' + hex : hex\r\n            }).join('')\r\n        }\r\n        return a == b || rgbToHex(a) == b || rgbToHex(b) == a;\r\n    }\r\n\r\n    getTile(xOffset,yOffset){\r\n        let tileX = Math.floor(xOffset / (this.playfield.tileSize));\r\n        let tileY = Math.floor(yOffset / (this.playfield.tileSize));\r\n\r\n        tileX = Math.min(tileX, this.playfield.cols - 1);\r\n        tileY = Math.min(tileY, (this.playfield.rows+this.playfield.spawnArea) - 1);\r\n\r\n        return this.playfield.board[tileY][tileX];\r\n    }\r\n\r\n    isInActivePiece(t){\r\n        let notActive = true;\r\n        let active = this.getActivePiece();\r\n        if(active){\r\n            for(let i=0; i<active.tiles.length; i++){\r\n                if(t.samePos(active.tiles[i])) return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    updatePalette() {\r\n\r\n        for (const c of this.palette) {\r\n            if(Sketcher.colorComp(this.drawColor, c.style.background)){\r\n                c.style.borderColor = \"white\";\r\n            }\r\n            else c.style.borderColor = \"transparent\";\r\n        }\r\n    }\r\n\r\n    draw(tile){\r\n        if(!this.isInActivePiece(tile)) {\r\n            tile.color = this.drawMode ? this.drawColor : null;\r\n            if(this.altKey && this.drawMode){\r\n                tile.ghost = this.drawMode;\r\n            }\r\n            else {\r\n                tile.active = this.drawMode;\r\n                tile.ghost = this.drawMode;\r\n                // tile.selected = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    drawRect(startPos, mousePos){\r\n        let startX = Math.min(startPos[0], mousePos[0]);\r\n        let startY = Math.min(startPos[1], mousePos[1]);\r\n        let endX = Math.max(startPos[0], mousePos[0]);\r\n        let endY = Math.max(startPos[1], mousePos[1]);\r\n\r\n        for(let row = startY; row<=endY; row++){\r\n            for(let col = startX; col<=endX; col++){\r\n                let tile = this.playfield.board[row][col];\r\n                this.draw(tile);\r\n\r\n\r\n\r\n                // tile.active = this.drawMode;\r\n                // // tile.selected = false;\r\n                // tile.color = this.drawMode ? this.drawColor : null;\r\n            }\r\n        }\r\n    }\r\n\r\n    select(tile, state=true){\r\n        // if(tile.active && this.shiftKey && this.mouseLeftDown){\r\n        if((this.shiftKey || this.ctrlKey) && (this.mouseLeftDown || this.mouseRightDown)){\r\n            tile.selected = state;\r\n        }\r\n    }\r\n\r\n    selectRect(startPos, mousePos, state){\r\n        let startX = Math.min(startPos[0], mousePos[0]);\r\n        let startY = Math.min(startPos[1], mousePos[1]);\r\n        let endX = Math.max(startPos[0], mousePos[0]);\r\n        let endY = Math.max(startPos[1], mousePos[1]);\r\n\r\n        for(let row = startY; row<=endY; row++){\r\n            for(let col = startX; col<=endX; col++){\r\n                let tile = this.playfield.board[row][col];\r\n                this.select(tile, state);\r\n            }\r\n        }\r\n    }\r\n\r\n    unselectAll(){\r\n        let tiles = this.playfield.getAllTiles();\r\n        for (let i=0; i<tiles.length; i++) {\r\n            let t = tiles[i];\r\n            t.selected = false;\r\n        }\r\n    }\r\n\r\n    // inDragBounds(tile){\r\n    //     return tile.x >= this.dragBounds.lowX \r\n    //         && tile.x <= this.dragBounds.highX \r\n    //         && tile.y >= this.dragBounds.lowY \r\n    //         && tile.y <= this.dragBounds.highY \r\n    // }\r\n\r\n    drag(curTile){\r\n        if(curTile !== this.startDragTile){\r\n            // console.log(curTile.x, curTile.y);\r\n\r\n            let clamp = (x,lower,higher) => Math.max(Math.min(x, higher), lower);\r\n            let shiftX = clamp(curTile.x,  this.dragBounds.lowX, this.dragBounds.highX);\r\n            let shiftY = clamp(curTile.y,  this.dragBounds.lowY, this.dragBounds.highY);\r\n\r\n            // erase and update selected\r\n            for(let i=0; i<this.selected.length; i++){\r\n                let t = this.selected[i];\r\n                this.playfield.board[t.y][t.x].active = false;\r\n                this.playfield.board[t.y][t.x].selected = false;\r\n                this.playfield.board[t.y][t.x].ghost = false;\r\n            }\r\n\r\n            for(let i=0; i<this.selected.length; i++){\r\n                this.selected[i].x = shiftX + this.selectionOffsets[i].x;\r\n                this.selected[i].y = shiftY + this.selectionOffsets[i].y;\r\n                let copy = this.selected[i].copy();\r\n                this.playfield.board[copy.y][copy.x] = copy;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nclass Tile {\r\n    constructor(x,y, active=false, color=null) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.active = active;\r\n        this.color = color;\r\n        this.selected = false;\r\n        this.ghost = false;\r\n    }\r\n\r\n    samePos(t){\r\n        return (this.x === t.x) && (this.y === t.y);\r\n    }\r\n\r\n    copy() {\r\n        \r\n        let copy = new Tile(this.x, this.y, this.active, this.color);\r\n        copy.selected = this.selected;\r\n        copy.ghost = this.ghost;\r\n        return copy;\r\n    }\r\n}\r\n\r\nclass Piece {\r\n    constructor(p, x=0, y=0, rot=0){\r\n        this.name = p;\r\n        this.pos = {x: x, y: y};\r\n        this.rot = rot;\r\n        this.offsets = Piece.pieces[this.name][this.rot];\r\n        this.color = Piece.pieces[this.name].color;\r\n        this.updateTiles();\r\n\r\n    }\r\n\r\n    copy() {\r\n        return new Piece(this.name, this.pos.x, this.pos.y, this.rot);\r\n    }\r\n\r\n    move(y, x){\r\n        this.pos.y += y;\r\n        this.pos.x += x;\r\n        this.updateTiles();\r\n    }\r\n\r\n    rotate(n){\r\n        this.rot = n;\r\n        this.offsets = Piece.pieces[this.name][this.rot];\r\n        this.updateTiles();\r\n    }\r\n\r\n    updateTiles(){\r\n        this.tiles = this.offsets.map((o) => {\r\n            return new Tile(this.pos.x+o[1], this.pos.y+o[0], true, this.color);\r\n        });\r\n    }\r\n\r\n    static pieces = {\r\n        i : {\r\n            0 : [[1,0],[1,1],[1,2],[1,3]],\r\n            1 : [[0,2],[1,2],[2,2],[3,2]],\r\n            2 : [[2,0],[2,1],[2,2],[2,3]],\r\n            3 : [[0,1],[1,1],[2,1],[3,1]],\r\n            color : \"#0f9bd7\"\r\n        },\r\n        j :{\r\n            0 : [[0,0],[1,0],[1,1],[1,2]],\r\n            1 : [[0,1],[0,2],[1,1],[2,1]],\r\n            2 : [[1,0],[1,1],[1,2],[2,2]],\r\n            3 : [[2,0],[2,1],[1,1],[0,1]],\r\n            color : \"#2141c6\"\r\n        },\r\n        l :{\r\n            0 : [[1,0],[1,1],[1,2],[0,2]],\r\n            1 : [[0,1],[1,1],[2,1],[2,2]],\r\n            2 : [[1,0],[1,1],[1,2],[2,0]],\r\n            3 : [[0,0],[2,1],[1,1],[0,1]],\r\n            color : \"#e35b02\"\r\n        },\r\n        o :{\r\n            0 : [[0,1],[0,2],[1,1],[1,2]],\r\n            1 : [[0,1],[0,2],[1,1],[1,2]],\r\n            2 : [[0,1],[0,2],[1,1],[1,2]],\r\n            3 : [[0,1],[0,2],[1,1],[1,2]],\r\n            color : \"#e39f02\"\r\n        },\r\n        s :{\r\n            0 : [[1,0],[1,1],[0,1],[0,2]],\r\n            1 : [[0,1],[1,1],[1,2],[2,2]],\r\n            2 : [[2,0],[2,1],[1,1],[1,2]],\r\n            3 : [[0,0],[1,0],[1,1],[2,1]],\r\n            color : \"#59b101\"\r\n        },\r\n        t :{\r\n            0 : [[0,1],[1,0],[1,1],[1,2]],\r\n            1 : [[0,1],[1,1],[1,2],[2,1]],\r\n            2 : [[1,0],[1,1],[1,2],[2,1]],\r\n            3 : [[0,1],[1,0],[1,1],[2,1]],\r\n            color : \"#af298a\"\r\n        },\r\n        z :{\r\n            0 : [[0,0],[0,1],[1,1],[1,2]],\r\n            1 : [[0,2],[1,1],[1,2],[2,1]],\r\n            2 : [[1,0],[1,1],[2,1],[2,2]],\r\n            3 : [[0,1],[1,1],[1,0],[2,0]],\r\n            color : \"#d70f37\"\r\n        },\r\n    }\r\n\r\n\r\n}\r\n\r\nclass Queue {\r\n    pieces = [\"i\", \"j\", \"l\", \"t\", \"s\", \"z\", \"o\"];\r\n    queue = [];\r\n    queueIndex = 0;\r\n    bagStarts = new Set();\r\n\r\n    slots = 6;\r\n    slotSizeY = 4;\r\n    slotSizeX = 6;\r\n    showMax = 6;\r\n\r\n    constructor(tileSize=25) {\r\n        this.canvas = document.getElementById(\"queue\");\r\n        this.ctx = this.canvas.getContext(\"2d\");\r\n        this.tileSize = tileSize;\r\n\r\n        this.queueHeight =  this.tileSize*this.slots*this.slotSizeY;\r\n        this.queueWidth =  this.tileSize*this.slotSizeX;\r\n\r\n        this.canvas.height = this.queueHeight;\r\n        this.canvas.width = this.queueWidth;\r\n\r\n        this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);\r\n\r\n        this.updateQueue();\r\n        this.renderQueue();\r\n    }\r\n\r\n    copy() {\r\n        let copy = new Queue(this.tileSize);\r\n        copy.queue = structuredClone(this.queue);\r\n        copy.queueIndex = this.queueIndex;\r\n        return copy;\r\n    }\r\n\r\n    renderQueue() {\r\n        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\r\n\r\n        for (let i = this.queueIndex+1; i < this.queueIndex+8; i++) {\r\n\r\n            if(i < this.queueIndex+this.showMax){\r\n                this.drawPiece(new Piece(this.queue[i]), this.tileSize, this.tileSize + (i-(this.queueIndex+1))*3*this.tileSize); // TODO better spacing ?\r\n            }\r\n\r\n            // dividers\r\n            this.ctx.lineWidth = 2;\r\n            this.ctx.strokeStyle = (i) % 7 == 6 ? \"rgba(200,200,200,0.5)\" : \"rgba(100,100,100,0.2)\" ;\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(this.queueWidth-20,(i-(this.queueIndex+1)+1)*3*this.tileSize+(this.tileSize/2))\r\n            this.ctx.lineTo(this.queueWidth,(i-(this.queueIndex+1)+1)*3*this.tileSize+(this.tileSize/2))\r\n            this.ctx.stroke();\r\n        }\r\n    }\r\n\r\n    drawPiece(p,x,y){\r\n\r\n        for(let i=0; i<p.offsets.length; i++){\r\n            let o = p.offsets[i];\r\n\r\n            let p1x = x + o[1]*this.tileSize;\r\n            let p1y = y + o[0]*this.tileSize;\r\n            this.ctx.fillStyle = p.color;\r\n            this.ctx.fillRect(p1x,p1y,this.tileSize,this.tileSize);\r\n        }\r\n    }\r\n\r\n    updateQueue(q=[]) {\r\n        //validate\r\n        // pieces = [\"i\", \"j\", \"l\", \"t\", \"s\", \"z\", \"o\"];\r\n        // for(let i=0; i<q.length; i++){\r\n        //     if(!Piece.pieces.includes(q[i])){\r\n        //         return false;\r\n        //     }\r\n        // }\r\n\r\n        if(q.length > 0){\r\n            this.queue = this.queue.slice(0,this.queueIndex);\r\n            this.queue = [...this.queue, ...q];\r\n        }\r\n\r\n        while (this.queue.length-this.queueIndex <= this.showMax) {\r\n            // Fisher Yates shuffle\r\n            let shuffle = (arr) => {\r\n                let copy = structuredClone(arr)\r\n                for (let i = copy.length - 1; i > 0; i--) {\r\n                    let j = Math.floor(Math.random() * (i + 1));\r\n                    [copy[i], copy[j]] = [copy[j], copy[i]];\r\n                }\r\n                return copy\r\n            }\r\n            this.queue.push(...shuffle(Object.entries(Piece.pieces).map((x) => x[0])));\r\n            // this.bagStarts.add(this.queue.length);\r\n            // console.log(...this.bagStarts);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    setQueueIndex(i){\r\n        this.queueIndex = i;\r\n    }\r\n\r\n    queueStep(){\r\n        this.updateQueue();\r\n        this.queueIndex += 1;\r\n    }\r\n\r\n    getCurrent(){\r\n        return this.queue[this.queueIndex];\r\n    }\r\n\r\n    setCurrent(p){\r\n        this.queue[this.queueIndex] = p; \r\n    }\r\n\r\n    reset() {\r\n        this.queue = [];\r\n        this.queueIndex = 0;\r\n        this.updateQueue();\r\n    }\r\n\r\n}\r\n\r\n\r\nclass Hold {\r\n    pieceName;\r\n\r\n    constructor(tileSize=30) {\r\n\r\n        this.canvas = document.getElementById(\"hold\");\r\n        this.ctx = this.canvas.getContext(\"2d\");\r\n        this.tileSize = tileSize;\r\n\r\n        this.holdHeight =  this.tileSize*5;\r\n        this.holdWidth =  this.tileSize*6;\r\n\r\n        this.canvas.height = this.holdHeight;\r\n        this.canvas.width = this.holdWidth;\r\n\r\n        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\r\n\r\n        this.renderHold();\r\n    }\r\n\r\n    copy() {\r\n        let copy = new Hold(this.tileSize);\r\n        copy.pieceName = this.pieceName;\r\n        return copy;\r\n    }\r\n\r\n\r\n    renderHold(){\r\n        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\r\n        if(this.pieceName){\r\n            this.drawPiece(new Piece(this.pieceName), this.tileSize, this.tileSize); //TODO better spacing \r\n        }\r\n    }\r\n\r\n    drawPiece(p,x,y){\r\n        for(let i=0; i<p.offsets.length; i++){\r\n            let o = p.offsets[i];\r\n            let p1x = x + o[1]*this.tileSize;\r\n            let p1y = y + o[0]*this.tileSize;\r\n            this.ctx.fillStyle = p.color;\r\n            this.ctx.fillRect(p1x,p1y,this.tileSize,this.tileSize);\r\n        }\r\n    }\r\n    \r\n    getHold(){\r\n        return this.pieceName;\r\n    }\r\n    \r\n    setHold(n){\r\n        this.pieceName = n;\r\n    }\r\n\r\n}\r\n\r\n// class histNode{\r\n\r\n//     constructor(board=[], change=[], piece=''){\r\n//         this.board = board;\r\n//         this.change = change;\r\n//         this.piece = piece;\r\n\r\n//         this.parent;\r\n//         this.children = []\r\n//     }\r\n// }\r\n\r\nclass BoardHistory {\r\n    states = []\r\n    stateIndex = null;\r\n\r\n\r\n    // constructor(){\r\n    //     this.statesRoot = new histNode(); \r\n    // }\r\n    \r\n    // static stateToString(state){\r\n    //     //build bitBoards\r\n    //     let colors = Object.entries(Piece.pieces).map((e) => e[1].color).concat([\"#888888\"]);\r\n    //     let bitBoards = []\r\n    //     for( let row of state.playfield.board){\r\n    //         for(let t of row){\r\n    //             for(let i=0; i<colors.length; i++){\r\n    //                 if(bitBoards.length < colors.length){\r\n    //                     bitBoards.push(\"\")\r\n    //                 }\r\n    //                 if(t.active && Sketcher.colorComp(t.color, colors[i])){\r\n    //                     bitBoards[i] += '1';\r\n    //                 }\r\n    //                 else bitBoards[i] += '0';\r\n    //             }\r\n    //         }\r\n    //     }\r\n\r\n    //     // convert to BigInts\r\n    //     let boards = [];\r\n    //     for(const b of bitBoards){\r\n    //         boards.push(BigInt(\"0b\" + b))\r\n    //     }\r\n\r\n    //     let c = BigInt(0);\r\n    //     for (const b of boards){\r\n    //         c = c | b;\r\n    //     }\r\n    //     // console.log(c)\r\n\r\n    // }\r\n\r\n    addState(playfield, queue, hold){\r\n        // overwrite states in front if in past\r\n        if(this.stateIndex < this.states.length-1){\r\n            this.states = this.states.slice(0,this.stateIndex+1);\r\n        }\r\n\r\n        let state = {playfield: playfield, \r\n                    queue: queue,\r\n                    hold: hold}\r\n        this.states.push(state);\r\n\r\n        if(this.stateIndex !== null) {\r\n            this.stateIndex += 1;\r\n        }\r\n        else this.stateIndex = 0;\r\n    }\r\n\r\n    getState(n=0){\r\n        if(this.stateIndex !== null){\r\n            this.stateIndex = Math.max(Math.min(this.stateIndex + n, this.states.length-1 ),0)  ;\r\n            return this.states[this.stateIndex];\r\n        }\r\n    }\r\n\r\n    reset() {\r\n        this.states = [];\r\n        this.stateIndex = null;\r\n    }\r\n}\r\n\r\nclass InputManager {\r\n    keysDown = {};\r\n    lastKey = null;\r\n\r\n    constructor(callback) {\r\n        // this.timer = new Worker(\"timer.js\");\r\n        window.addEventListener(\"keydown\", (e) => this.keyDown(e));\r\n        window.addEventListener(\"keyup\", (e) => this.keyUp(e));\r\n\r\n        document.getElementById(\"field\").addEventListener('focusout', this.resetInputs); \r\n\r\n        this.callback = callback;\r\n    }\r\n\r\n    resetInputs(e){\r\n        this.keysDown = {};\r\n        this.lastKey = null;\r\n    }\r\n\r\n    keyDown(e) {\r\n        if(!this.keysDown[e.key]) {\r\n            this.keysDown[e.key] = performance.now();\r\n            this.lastKey = e.key;\r\n            this.callback(e.key, true);\r\n        }\r\n    }\r\n\r\n    keyUp(e) {\r\n        // console.log(e.key, performance.now() - this.keysDown[e.key])\r\n        this.keysDown[e.key] = null;\r\n        this.callback(e.key, false);\r\n    }\r\n\r\n}\r\n\r\nclass Settings{\r\n    // gravity = 1000;\r\n\r\n    // Max's settings\r\n    // das = 100;\r\n    // arr = 0;\r\n    // softDrop = 0;\r\n    // keybinds = {\r\n    //     leftKey: 's',\r\n    //     rightKey: 'f',\r\n    //     softKey: 'd',\r\n    //     hardKey: 'j',\r\n    //     holdKey: 'e',\r\n    //     crKey: 'l',\r\n    //     ccrKey: 'k',\r\n    //     r180Key: ';',\r\n    //     restartKey: 'r',\r\n    //     undoKey: 'z',\r\n    //     redoKey: 'a',\r\n    // };\r\n\r\n    // Default Settings\r\n    das = 130;\r\n    arr = 50;\r\n    softDrop = 20;\r\n    keybinds = {\r\n        leftKey: 'ArrowLeft',\r\n        rightKey: 'ArrowRight',\r\n        softKey: 'ArrowDown',\r\n        hardKey: ' ',\r\n        holdKey: 'c',\r\n        crKey: 'ArrowUp',\r\n        ccrKey: 'z',\r\n        r180Key: 'a',\r\n        restartKey: 'r',\r\n        undoKey: 'q',\r\n        redoKey: 'w',\r\n        // spinKey: 'a',\r\n    };\r\n\r\n    constructor(input, pauseInput, resumeInput, board){\r\n        this.input = input;\r\n        this.pause = pauseInput;\r\n        this.resume = resumeInput;\r\n        this.board = board;\r\n\r\n        this.loadSettings();\r\n\r\n        let s = document.getElementById(\"settings\")\r\n        \r\n        s.addEventListener(\"focusin\", (e) => this.pause());\r\n        s.addEventListener(\"focusout\", (e) => this.resume());\r\n\r\n        s.innerHTML = \"\";\r\n\r\n        let html = \"\";\r\n        // html += \"<button onclick=\\\"game.startGame()\\\"> New game </button>\";\r\n\r\n        // queue\r\n        html += \"<div class=\\\"setting\\\"><p>update queue</p><input id=\\\"queueUpdate\\\"></input></div>\";\r\n\r\n        // timing\r\n        html += \"<div id=\\\"timing\\\">\"\r\n        for(const [k, v] of Object.entries(this)){\r\n            if(k === \"das\" || k === \"arr\" || k === \"softDrop\"){\r\n                html += \"<div class=\\\"setting\\\">\";\r\n                html += \"<p id=\\\"\" + k + \"Text\" + \"\\\">\" + k + \" (ms)\" +  \" : \" + v + \"</p>\";\r\n                html += \"<input id=\\\"\" + k + \"Field\" + \"\\\">\" + \"</input>\";\r\n                html += \"</div>\";\r\n            }\r\n        }\r\n        html += \"</div>\"\r\n\r\n        html += \"<div id=\\\"keyBinds\\\">\"\r\n        html += \"<button id=\\\"changeAll\\\"> Change All Keybinds</button>\"\r\n        for(const [k, v] of Object.entries(this.keybinds)){\r\n            html += \"<div class=\\\"setting\\\">\";\r\n            html += \"<p id=\\\"\" + k + \"Text\" + \"\\\" >\" + k + \" : </p>\"\r\n            html += \"<p id=\\\"\" + k + \"\\\">\" + (v === \" \" ? \"Space\" : v) + \"</p>\";\r\n            html += \"<button id =\\\"\" + k + \"Button\\\">change</button>\"\r\n            html += \"</div>\";\r\n        }\r\n        html += \"</div>\"\r\n        document.getElementById(\"settings\").innerHTML += html;\r\n\r\n        // add listeners\r\n        document.getElementById(\"queueUpdate\").addEventListener(\"keyup\", (e) => {\r\n            if(e.key === \"Enter\"){\r\n                let newQ = document.getElementById(\"queueUpdate\").value.split(\"\");\r\n\r\n                // validate\r\n                let pieces = [\"i\", \"j\", \"l\", \"t\", \"s\", \"z\", \"o\"];\r\n                for(let i=0; i<newQ.length; i++){\r\n                    if(!pieces.includes(newQ[i])){\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                this.board.queue.updateQueue(newQ);\r\n                this.board.hold.setHold(null);\r\n                document.getElementById(\"queueUpdate\").value = \"\";\r\n                document.getElementById(\"queueUpdate\").blur();\r\n            }\r\n        })\r\n\r\n\r\n        for(const [k, v] of Object.entries(this)){\r\n            if(k === \"das\" || k === \"arr\" || k === \"softDrop\"){\r\n                document.getElementById(k + \"Field\").addEventListener(\"keyup\", (e) => {\r\n                    if(e.key === \"Enter\"){\r\n                        this.update(k, document.getElementById(k+\"Field\").value);\r\n                        document.getElementById(k+\"Field\").value = \"\";\r\n                        document.getElementById(k+\"Field\").blur();\r\n                    }\r\n                })\r\n            }\r\n        }\r\n\r\n        document.getElementById(\"changeAll\").addEventListener(\"click\", (e) => this.changeAllKeys());\r\n\r\n        for(const [k, v] of Object.entries(this.keybinds)){\r\n            document.getElementById(k+\"Button\").addEventListener(\"click\", (e) => {\r\n                document.getElementById(k+\"Button\").blur(); // needed to make sure spacebar doesn't retrigger button\r\n                this.updateKey(k);\r\n            })\r\n        }\r\n\r\n    }\r\n    \r\n    loadSettings() {\r\n        let cookieSettingsRaw = decodeURIComponent(document.cookie).split(\"; \").find((row) => row.startsWith(\"settings=\"));\r\n        if(cookieSettingsRaw){\r\n            let cookieSettings = JSON.parse(cookieSettingsRaw.split(\"=\")[1]);\r\n            this.das = cookieSettings.das;\r\n            this.arr = cookieSettings.arr;\r\n            this.softDrop = cookieSettings.softDrop;\r\n            this.keybinds = cookieSettings.keybinds;\r\n\r\n            //close settings pane\r\n            let s = document.getElementById(\"settings\")\r\n\r\n            // let tl1 = gsap.timeline();\r\n            // tl1.to(\"#settingsExpandWrapper\" , {\r\n            //     scaleX: 0,\r\n            //     duration: 1,\r\n            //     ease: \"none\",\r\n            // });\r\n\r\n\r\n            // let tl2 = gsap.timeline();\r\n            //     tl2.to(\"#settings\", {\r\n            //     x: 400,\r\n            //     duration: 1,\r\n            //     // ease: \"none\",\r\n            // });\r\n\r\n        }\r\n    }\r\n\r\n    saveSettings() {\r\n        let cookie = {\r\n            das : this.das,\r\n            arr : this.arr,\r\n            softDrop : this.softDrop,\r\n            keybinds : this.keybinds\r\n        }\r\n\r\n        let x = new Date();\r\n        x.setTime(x.getTime() + 24*60*60*365*1000); // 1 year;\r\n        \r\n        document.cookie = \"settings=\" + encodeURIComponent(JSON.stringify(cookie))\r\n                            + \"; expires=\" + x.toUTCString();\r\n\r\n    }\r\n\r\n    removeFocus() {\r\n        document.getElementById(\"queueUpdate\").blur();\r\n    }\r\n\r\n    updateDisplay(){\r\n        for(const [k, v] of Object.entries(this)){\r\n            if(k === \"das\" || k === \"arr\" || k === \"softDrop\"){\r\n                document.getElementById(k+\"Text\").innerHTML = k + \" (ms) : \" + v;\r\n            }\r\n        }\r\n\r\n        for(const [k, v] of Object.entries(this.keybinds)){\r\n            document.getElementById(k).innerHTML = (v === \" \" ? \"Space\" : v);\r\n        }\r\n\r\n        this.saveSettings();\r\n    }\r\n\r\n    async changeAllKeys(){\r\n        // this.pause();\r\n        // document.getElementById(\"changeAll\").blur(); // needed to make sure spacebar doesn't retrigger button\r\n        for(const [k, v] of Object.entries(this.keybinds)){\r\n            // document.getElementById(k+\"Text\").innerHTML = k + \" : \" + \"Waiting...\";\r\n            document.getElementById(k).innerHTML = \"Waiting...\";\r\n            let newKey = await this.awaitKey();\r\n            this.keybinds[k] = newKey;\r\n            this.updateDisplay();\r\n        }\r\n        document.getElementById(\"changeAll\").blur(); // needed to make sure spacebar doesn't retrigger button\r\n        // this.resume();\r\n    }\r\n\r\n    update(s, newVal){\r\n        this[s] = parseInt(newVal);\r\n        this.updateDisplay();\r\n    }\r\n\r\n    async updateKey(k){\r\n        this.pause();\r\n        document.getElementById(k).innerHTML = \"Waiting...\";\r\n\r\n        let newKey = await this.awaitKey();\r\n        this.keybinds[k] = newKey;\r\n\r\n        this.resume();\r\n        this.updateDisplay();\r\n    }\r\n\r\n    awaitKey() {\r\n        let waitKey = new Promise((resolve) => {\r\n            document.addEventListener(\"keydown\", (e) => {\r\n                e.preventDefault();\r\n                resolve(e.key);\r\n                }, {once: true}\r\n            )\r\n        })\r\n        return waitKey;\r\n    }\r\n}\r\n\r\nclass Game {\r\n    start = true;\r\n    startTime;\r\n    takingInput = true;\r\n\r\n    curDir;\r\n    dasFired = false;\r\n    softDrop = false;\r\n    dasCancel;\r\n    arrCancel;\r\n    softCancel;\r\n\r\n    constructor() {\r\n\r\n        this.input = new InputManager((key, state) => this.handleInput(key, state));\r\n        this.board = new GameBoard(20, 10, 30);\r\n        this.settings = new Settings(this.input, () => this.pauseInput(), () => this.resumeInput(), this.board);\r\n\r\n        this.lastTick = performance.now();\r\n        this.lastRender = this.lastTick;\r\n        this.tickLength = 50;\r\n    }\r\n\r\n\r\n    update() {\r\n        // game logic\r\n        if(this.start){\r\n            this.board.update();\r\n            // this.board.activePiece = this.board.queue.getCurrent();\r\n            if(this.dasFired && this.settings.arr === 0){\r\n                this.board.shiftInstant(this.curDir);\r\n            }\r\n            // // spawn piece\r\n            // if(!this.board.activePiece){\r\n            //     // stop game if can't spawn\r\n            //     if(!this.board.spawnPiece()) {\r\n            //         this.start = false;\r\n            //     }\r\n            // }\r\n            // else{\r\n            // }\r\n        }\r\n    }\r\n\r\n    initiateDas(key,dir) {\r\n        this.cancelDas();\r\n        this.curDir = dir;\r\n\r\n        this.board.shiftPiece(dir);\r\n        this.dasCancel = setTimeout( () => {\r\n            this.dasFired = true;\r\n            if(this.input.keysDown[key]) {\r\n                if(this.settings.arr === 0) this.board.shiftInstant(dir, this.settings.softDrop === 0 && this.softDrop);\r\n                else{\r\n                    this.arrCancel = setInterval(() => {\r\n                        if(this.input.keysDown[key]) this.board.shiftPiece(dir) \r\n                        else this.cancelDas();\r\n                    }, this.settings.arr);\r\n                }\r\n            }\r\n            else this.cancelDas();\r\n        }, this.settings.das);\r\n    }\r\n\r\n    cancelDas() {\r\n        if(this.dasCancel) clearTimeout(this.dasCancel);\r\n        if(this.arrCancel) clearInterval(this.arrCancel);\r\n        this.dasFired = false;\r\n        this.dasCancel = null;\r\n        this.arrCancel = null;\r\n        this.curDir = null;\r\n    }\r\n\r\n    handleInput(key, state) {\r\n        if(this.takingInput){\r\n            //special keys\r\n            if(key === \"Control\"){\r\n                if(state) this.board.sketcher.ctrlKey = true;\r\n                else this.board.sketcher.ctrlKey = false;\r\n            }\r\n            if(key === \"Shift\"){\r\n                if(state) this.board.sketcher.shiftKey = true;\r\n                else this.board.sketcher.shiftKey = false;\r\n            }\r\n            if(key === \"Alt\"){\r\n                if(state) this.board.sketcher.altKey = true;\r\n                else this.board.sketcher.altKey = false;\r\n            }\r\n            if(key === \"Escape\"){\r\n                this.board.sketcher.unselectAll();\r\n            }\r\n\r\n            // game controls\r\n            if(key === this.settings.keybinds.leftKey){\r\n                if(state) this.initiateDas(key,\"left\");\r\n                else if(this.curDir === \"left\") this.cancelDas();\r\n            }\r\n            else if(key === this.settings.keybinds.rightKey){\r\n                if(state) this.initiateDas(key,\"right\");\r\n                else if(this.curDir === \"right\") this.cancelDas();\r\n            }\r\n            else if(key === this.settings.keybinds.softKey){\r\n                if(state){\r\n                    this.softDrop = true;\r\n                    if(this.settings.softDrop === 0) this.board.shiftInstant(\"down\");\r\n                    this.softCancel = setInterval(() => {\r\n                        if(this.input.keysDown[key]) this.board.shiftPiece(\"down\");\r\n                        else clearInterval(this.softCancel); \r\n                    }, this.settings.softDrop);\r\n                }\r\n                else if(this.softDrop) {\r\n                    this.softDrop = false;\r\n                    clearInterval(this.softCancel);\r\n                }\r\n            }\r\n            else if(state && key === this.settings.keybinds.hardKey){\r\n                this.board.hardDrop();\r\n                // this.queue.queueStep();\r\n            }\r\n            else if(state && key === this.settings.keybinds.holdKey){\r\n                this.board.holdPiece();\r\n            }\r\n            else if(state && key === this.settings.keybinds.crKey){\r\n                this.board.rotateActive(1);\r\n            }\r\n            else if(state && key === this.settings.keybinds.ccrKey){\r\n                this.board.rotateActive(-1);\r\n            }\r\n            else if(state && key === this.settings.keybinds.r180Key){\r\n                this.board.rotateActive(2);\r\n            }\r\n            else if(state && key === this.settings.keybinds.restartKey){\r\n                this.startGame();\r\n            }\r\n            else if(state && key === this.settings.keybinds.undoKey){\r\n                this.board.setState(-1);\r\n            }\r\n            else if(state && key === this.settings.keybinds.redoKey){\r\n                this.board.setState(1);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    // dumb\r\n    spinBoard() {\r\n        let gameBoard = document.getElementById(\"gameBoard\");\r\n        if(gsap.getProperty(gameBoard, \"rotation\") === 0){\r\n            let tl = gsap.timeline();\r\n            tl.to(gameBoard, {\r\n                rotation: 360,\r\n                duration: 2,\r\n                repeat: -1,\r\n                ease: \"none\",\r\n            }).set(gameBoard, {rotation: 0});\r\n        }\r\n    }\r\n\r\n    render() {\r\n        this.board.renderBoard();\r\n    }\r\n\r\n    startGame() {\r\n        this.startTime = performance.now();\r\n        this.board.resetBoard();\r\n        this.start = true;\r\n    }\r\n\r\n    pauseInput(){\r\n        this.takingInput = false;\r\n        this.board.isPaused = true;\r\n    }\r\n\r\n    resumeInput(){\r\n        this.takingInput = true;\r\n        this.board.isPaused = false;\r\n    }\r\n\r\n}\r\n\r\n\r\nlet game = new Game();\r\n(() => {\r\n    function main(tFrame){\r\n        game.stopId = window.requestAnimationFrame(main);\r\n\r\n        const nextTick = game.lastTick + game.tickLength;\r\n        let numTicks = 0;\r\n\r\n        if(tFrame > nextTick){\r\n            const timeSinceTick = tFrame - game.lastTick;\r\n            numTicks = Math.floor(timeSinceTick / game.tickLength);\r\n\r\n        }\r\n\r\n        for (let i = 0; i < numTicks; i++) {\r\n            game.lastTick += game.tickLength;\r\n            game.update(game.lastTick);\r\n        }\r\n\r\n        game.render();\r\n    }\r\n\r\n    main(performance.now());\r\n})()\r\n\r\n\r\n\n\n//# sourceURL=webpack://sketris/./src/sketris.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseColor: () => (/* binding */ parseColor)\n/* harmony export */ });\nlet parseColor = (str) => {\r\n    if ('#' == str[0] && 7 == str.length) {\r\n        return {\r\n            r: parseInt(str.slice(1, 3), 16),\r\n            g: parseInt(str.slice(3, 5), 16),\r\n            b: parseInt(str.slice(5, 7), 16),\r\n            a: 1\r\n        }\r\n    }\r\n    if (0 == str.indexOf('rgba(')) {\r\n        str = str.match(/rgba\\(([^)]+)\\)/)[1];\r\n        var parts = str.split(/ *, */).map(Number);\r\n        return {\r\n            r: parts[0],\r\n            g: parts[1],\r\n            b: parts[2],\r\n            a: parts[3]\r\n        }\r\n    }\r\n    if (0 == str.indexOf('rgb(')) {\r\n        str = str.match(/rgb\\(([^)]+)\\)/)[1];\r\n        var parts = str.split(/ *, */).map(Number);\r\n        return {\r\n            r: parts[0],\r\n            g: parts[1],\r\n            b: parts[2],\r\n            a: 1\r\n        }\r\n    }\r\n}\n\n//# sourceURL=webpack://sketris/./src/utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	__webpack_require__("./src/sketris.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/utils.js");
/******/ 	
/******/ })()
;